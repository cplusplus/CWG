<HTML>
<HEAD>
<meta http-equiv="Content-Type" content="text/html; charset=us-ascii">
<TITLE>
    CWG Issue 522</TITLE>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<STYLE TYPE="text/css">
  INS { text-decoration:none; font-weight:bold; background-color:#A0FFA0 }
  .INS { text-decoration:none; background-color:#D0FFD0 }
  DEL { text-decoration:line-through; background-color:#FFA0A0 }
  .DEL { text-decoration:line-through; background-color: #FFD0D0 }
  @media (prefers-color-scheme: dark) {
    HTML { background-color:#202020; color:#f0f0f0; }
    A { color:#5bc0ff; }
    A:visited { color:#c6a8ff; }
    A:hover, a:focus { color:#afd7ff; }
    INS { background-color:#033a16; color:#aff5b4; }
    .INS { background-color: #033a16; }
    DEL { background-color:#67060c; color:#ffdcd7; }
    .DEL { background-color:#67060c; }
  }
  SPAN.cmnt { font-family:Times; font-style:italic }
</STYLE>
</HEAD>
<BODY>
<P><EM>This is an unofficial snapshot of the ISO/IEC JTC1 SC22 WG21
  Core Issues List revision 116c.
  See http://www.open-std.org/jtc1/sc22/wg21/ for the official
  list.</EM></P>
<P>2025-03-08</P>
<HR>
<A NAME="522"></A><H4>522.
  
Array-to-pointer decay in template argument deduction
</H4>
<B>Section: </B>13.10.3.2&#160; [<A href="https://wg21.link/temp.deduct.call">temp.deduct.call</A>]
 &#160;&#160;&#160;

 <B>Status: </B>CD1
 &#160;&#160;&#160;

 <B>Submitter: </B>Daveed Vandevoorde
 &#160;&#160;&#160;

 <B>Date: </B>3 June 2005<BR>


<P>[Voted into WP at the October, 2006 meeting.]</P>

<P>Consider the following example:</P>

<PRE>
    char* cmdline3_[1] = {};

    template&lt;class charT&gt;
    void func(const charT* const argv[]) {}

    int main()
    {
        func(cmdline3_);
    }
</PRE>

<P>In terms of the process described in 13.10.3.2 [<A href="https://wg21.link/temp.deduct.call">temp.deduct.call</A>],
<TT>P</TT> is <TT>const charT* const *</TT> and <TT>A</TT> is
<TT>char*[1]</TT>.  According to the first bullet in paragraph 2,
the type used in deduction is not <TT>A</TT> but &#8220;the pointer
type produced by the array-to-pointer standard conversion.&#8221;</P>

<P>According to paragraph 4,</P>

<BLOCKQUOTE>

In general, the deduction process attempts to find template argument
values that will make the deduced <TT>A</TT> identical to <TT>A</TT>
(after the type <TT>A</TT> is transformed as described
above). However, there are three cases that allow a difference:

</BLOCKQUOTE>

<P>In this example, the deduced <TT>A</TT> is <I>not</I>
identical to the transformed <TT>A</TT>, because the deduced
<TT>A</TT> has additional cv-qualification, so the three exceptions
must be examined to see if they apply.  The only one that might
apply is the second bullet of paragraph 4:</P>

<BLOCKQUOTE>

<UL><LI>
<TT>A</TT> can be another pointer or pointer to member type
that can be converted to the deduced <TT>A</TT> via a qualification
conversion (7.3.6 [<A href="https://wg21.link/conv.qual">conv.qual</A>]).</LI></UL>

</BLOCKQUOTE>

<P>However, <TT>A</TT> is not a pointer type but an array type;
this provision does not apply and deduction fails.</P>

<P>It has been argued that the phrase &#8220;after the type <TT>A</TT>
is transformed as described above&#8221; should be understood to
apply to the <TT>A</TT> in the three bullets of paragraph 4.  If
that is the intent, the wording should be changed to make that
explicit.</P>

<P><B>Proposed resolution (October, 2005):</B></P>

<P>Add the indicated words to 13.10.3.2 [<A href="https://wg21.link/temp.deduct.call#4">temp.deduct.call</A>] paragraph 4:
</P>

<BLOCKQUOTE>

<P>In general, the deduction process attempts to find template
argument values that will make the deduced <TT>A</TT> identical
to <TT>A</TT> (after the type <TT>A</TT> is transformed as described
above). However, there are three cases that allow a difference:</P>

<UL>

<LI><P>If the original <TT>P</TT> is a reference type, the
deduced <TT>A</TT> (i.e., the type referred to by the reference) can
be more cv-qualified than <INS>the transformed</INS> <TT>A</TT>.</P></LI>

<LI><P>
<INS>The transformed</INS> <TT>A</TT> can be another pointer or
pointer to member type that can be converted to the deduced <TT>A</TT>
via a qualification conversion (7.3.6 [<A href="https://wg21.link/conv.qual">conv.qual</A>]).</P></LI>

<LI><P>If <TT>P</TT> is a class, and <TT>P</TT> has the
form <I>template-id</I>, then <INS>the transformed</INS> <TT>A</TT> can be
a derived class of the deduced <TT>A</TT>. Likewise, if <TT>P</TT> is
a pointer to a class of the form <I>template-id</I>, <INS>the
transformed</INS> <TT>A</TT> can be a pointer to a derived class pointed
to by the deduced <TT>A</TT>.</P></LI>

</UL>

</BLOCKQUOTE>

<BR><BR>
</BODY>
</HTML>
