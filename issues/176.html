<HTML>
<HEAD>
<meta http-equiv="Content-Type" content="text/html; charset=us-ascii">
<TITLE>
    CWG Issue 176</TITLE>
<STYLE TYPE="text/css">
  INS { text-decoration:none; font-weight:bold; background-color:#A0FFA0 }
  .INS { text-decoration:none; background-color:#D0FFD0 }
  DEL { text-decoration:line-through; background-color:#FFA0A0 }
  .DEL { text-decoration:line-through; background-color: #FFD0D0 }
  SPAN.cmnt { font-family:Times; font-style:italic }
</STYLE>
</HEAD>
<BODY>
<P><EM>This is an unofficial snapshot of the ISO/IEC JTC1 SC22 WG21
  Core Issues List revision 116.
  See http://www.open-std.org/jtc1/sc22/wg21/ for the official
  list.</EM></P>
<P>2024-12-19</P>
<HR>
<A NAME="176"></A><H4>176.
  
Name injection and templates
</H4>
<B>Section: </B>Clause 11&#160; [<A href="https://wg21.link/class">class</A>]
 &#160;&#160;&#160;

 <B>Status: </B>TC1
 &#160;&#160;&#160;

 <B>Submitter: </B>John Spicer
 &#160;&#160;&#160;

 <B>Date: </B>21 February 1999<BR>



<P>There is some controversy about whether class name injection applies
to class templates.  If it does apply, what is injected?  Is a class
name injected or is the thing that is injected actually a template?</P>

<P>Clause 11 [<A href="https://wg21.link/class#2">class</A>] paragraph 2
says,</P>
<BLOCKQUOTE>
The <I>class-name</I> is also inserted into the scope of the class
itself.
</BLOCKQUOTE>

In general, clause 9 applies to both classes and class templates, so I
would take this to mean that class name imjection does indeed apply to
class templates.  One problem with this is that clause 9 uses the
syntactic term <I>class-name</I>, which I would take to imply that the
inserted name is always a class.  This is clearly unacceptable for
class templates as it makes the template itself unusable from with the
template.  For example:

<PRE>
    template &lt;class T&gt; struct A {
        A&lt;T*&gt; ptr;    // Invalid: A refers to a class
    };
</PRE>

<P>Clearly the injected name must be usable as both a class and a
class template.  This kind of magic already exists in the standard.
In 13.8.2 [<A href="https://wg21.link/temp.local">temp.local</A>]
 it says,</P>

<BLOCKQUOTE>
Within the scope of a class template, when the name of the template is
neither qualified nor followed by <TT>&lt;</TT>, it is equivalent to
the name of the template followed by the
<I>template-parameter</I>s enclosed in &lt;&gt;.
</BLOCKQUOTE>

<P>The proposal here is that we clarify that name injection does
indeed apply to class templates, and that it is the injected name that
has the special property of being usable as both a class and a
template name (as described in
13.8.2 [<A href="https://wg21.link/temp.local">temp.local</A>]
).  This would eliminate
the need for special wording regarding the qualification of the name,
but would achieve the same result.  This would also make this
"special" name available to a derived class of a class template
&#8212; something which is necessary if the benefits of class name
injection are to be made uniformly available for class templates, too.</P>

<PRE>
    template &lt;class T&gt; struct Base {
        Base* p;
        Base&lt;T*&gt;* p2;
        ::Base* p3;    // Error: only injected name usable as class
    };

    template &lt;class T&gt; struct Derived: public Base&lt;T&gt; {
        Base* p;    // Now okay
        Base&lt;T*&gt;* p2;    // Still okay
        Derived::Base* p3;    // Now okay
</PRE>

Note that by giving the special attribute of being usable as both a
class and a template to the injected name it is now clear where this
attribute can and cannot be used.

<P>(See paper J16/99-0010 = WG21 N1187.)</P>

<P><B>Proposed resolution (10/00):</B></P>

<P><I>[Note: these changes depend on the resolution for <A HREF="147.html">issue 147</A>.]</I></P>

<P>Replace 13.8.2 [<A href="https://wg21.link/temp.local">temp.local</A>] paragraphs 1 and 2 with the
following:</P>

<BLOCKQUOTE>

<P>Like normal (non-template) classes, class templates have an
injected-class-name (Clause 11 [<A href="https://wg21.link/class">class</A>]).  The
injected-class-name can be used with or without a
<I>template-argument-list</I>.  When it is used without a
<I>template-argument-list</I>, it is equivalent to the
injected-class-name followed by the <I>template-parameter</I>s of the
class template enclosed in <TT>&lt;&gt;</TT>.  When it is used with a
<I>template-argument-list</I>, it refers to the specified class
template specialization, which could be the current specialization or
another specialization.</P>

<P>Within the scope of a class template specialization or partial
specialization, when the injected-class-name is not followed by a
<TT>&lt;</TT>, it is equivalent to the injected-class-name followed by
the <I>template-argument</I>s of the class template specialization or
partial specialization enclosed in <TT>&lt;&gt;</TT>.
[<I>Example:</I>
</P>

<PRE>
    template&lt;class T&gt; class Y;
    template&lt;&gt; class Y&lt;int&gt; {
        Y* p;          // <I>meaning</I> Y&lt;int&gt;
        Y&lt;char&gt;* q;    // <I>meaning</I> Y&lt;char&gt;
    };
</PRE>

<P>&#8212;<I>end example</I>]</P>

<P>The injected-class-name of a class template or class template
specialization can be used either with or without a
<I>template-argument-list</I> wherever it is in scope.
[<I>Example:</I>
</P>

<PRE>
    template &lt;class T&gt; struct Base {
        Base* p;
    };

    template &lt;class T&gt; struct Derived: public Base&lt;T&gt; {
        typename Derived::Base* p;  // <I>meaning</I> Derived::Base&lt;T&gt;
    };
</PRE>

<P>&#8212;<I>end example</I>]</P>

<P>A lookup that finds an injected-class-name (6.5.2 [<A href="https://wg21.link/class.member.lookup">class.member.lookup</A>]) can result in an ambiguity in certain cases (for
example, if it is found in more than one base class).  If all of the
injected-class-names that are found refer to specializations of the
same class template, and if the name is followed by a
<I>template-argument-list</I>, the reference refers to the class
template itself and not a specialization thereof, and is not
ambiguous.  [<I>Example:</I>
</P>

<PRE>
    template &lt;class T&gt; struct Base { };
    template &lt;class T&gt; struct Derived: Base&lt;int&gt;, Base&lt;char&gt; {
        typename Derived::Base b;            // <I>error: ambiguous</I>
        typename Derived::Base&lt;double&gt; d;    // <I>OK</I>
    };
</PRE>

<P>&#8212;<I>end example</I>]</P>

<P>When the normal name of the template (i.e., the name from the
enclosing scope, not the injected-class-name) is used without a
<I>template-argument-list</I>, it refers to the class template itself
and not a specialization of the template.  [<I>Example:</I>
</P>

<PRE>
    template &lt;class T&gt; class X {
        X* p;         // <I>meaning</I> X&lt;T&gt;
        X&lt;T&gt;* p2;
        X&lt;int&gt;* p3;
        ::X* p4;      // <I>error: missing template argument list</I>
                      // ::X <I>does not refer to the injected-class-name</I>
    };
</PRE>

<P>&#8212;<I>end example</I>]</P>

</BLOCKQUOTE>

<BR><BR>
</BODY>
</HTML>
