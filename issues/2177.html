<HTML>
<HEAD>
<meta http-equiv="Content-Type" content="text/html; charset=us-ascii">
<TITLE>
    CWG Issue 2177</TITLE>
<STYLE TYPE="text/css">
  INS { text-decoration:none; font-weight:bold; background-color:#A0FFA0 }
  .INS { text-decoration:none; background-color:#D0FFD0 }
  DEL { text-decoration:line-through; background-color:#FFA0A0 }
  .DEL { text-decoration:line-through; background-color: #FFD0D0 }
  SPAN.cmnt { font-family:Times; font-style:italic }
</STYLE>
</HEAD>
<BODY>
<P><EM>This is an unofficial snapshot of the ISO/IEC JTC1 SC22 WG21
  Core Issues List revision 116.
  See http://www.open-std.org/jtc1/sc22/wg21/ for the official
  list.</EM></P>
<P>2024-12-19</P>
<HR>
<A NAME="2177"></A><H4>2177.
  
Placement <TT>operator delete</TT> and parameter copies
</H4>
<B>Section: </B>7.6.2.8&#160; [<A href="https://wg21.link/expr.new">expr.new</A>]
 &#160;&#160;&#160;

 <B>Status: </B>CD5
 &#160;&#160;&#160;

 <B>Submitter: </B>Richard Smith
 &#160;&#160;&#160;

 <B>Date: </B>2015-09-30<BR>


<P>[Accepted as a DR at the November, 2017 meeting.]</P>



<P>Consider the following example:</P>

<PRE>
  void *operator new(size_t n, std::string s) {
    std::string t = std::move(s);
    std::cout &lt;&lt; "new " &lt;&lt; t &lt;&lt; std::endl;
    return operator new(n);
  }
  void operator delete(void*, std::string s) {
    std::cout &lt;&lt; "delete " &lt;&lt; s &lt;&lt; std::endl;
  }
  struct X { X() { throw 0; } };
  int main() {
    try {
      new ("longer than the small string buffer") X();
    } catch (...) {}
  }
</PRE>

<P>Current implementations print</P>

<PRE>
  new longer than the small string buffer
  delete
</PRE>

<P>because  the same <TT>std::string</TT> object is used for
both the new and delete calls.  We should introduce additional
copies to separate out the parameters in this case or make
non-trivially-copyable parameter types ill-formed here.</P>

<P><B>Notes from the October, 2015 meeting:</B></P>

<P>CWG favored limiting the parameters of an overloaded
deallocation function to trivially-copyable types.</P>

<P><B>Proposed resolution (October, 2017):</B></P>

<P>Change 7.6.2.8 [<A href="https://wg21.link/expr.new#24">expr.new</A>] paragraph 24 as follows:</P>

<BLOCKQUOTE>

If a <I>new-expression</I> calls a deallocation function, it passes the
value returned from the allocation function call as the first argument of
type <TT>void*</TT>. If a placement deallocation function is called, it is
passed the same additional arguments as were passed to the placement
allocation function, that is, the same arguments as those specified with
the <I>new-placement</I> syntax. If the implementation is allowed
to <INS>introduce a temporary object or</INS> make a copy of any argument
as part of the call to the allocation function, it is <DEL>allowed to make
a copy (of the same original value) as part of the call to the deallocation
function or to reuse the copy made as part of the call to the allocation
function. If the copy is elided in one place, it need not be elided in the
other</DEL> <INS>unspecified whether the same object is used in the call to
both the allocation and deallocation functions</INS>,

</BLOCKQUOTE>

<BR><BR>
</BODY>
</HTML>
