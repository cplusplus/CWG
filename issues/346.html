<HTML>
<HEAD>
<meta http-equiv="Content-Type" content="text/html; charset=us-ascii">
<TITLE>
    CWG Issue 346</TITLE>
<STYLE TYPE="text/css">
  INS { text-decoration:none; font-weight:bold; background-color:#A0FFA0 }
  .INS { text-decoration:none; background-color:#D0FFD0 }
  DEL { text-decoration:line-through; background-color:#FFA0A0 }
  .DEL { text-decoration:line-through; background-color: #FFD0D0 }
  SPAN.cmnt { font-family:Times; font-style:italic }
</STYLE>
</HEAD>
<BODY>
<P><EM>This is an unofficial snapshot of the ISO/IEC JTC1 SC22 WG21
  Core Issues List revision 116a.
  See http://www.open-std.org/jtc1/sc22/wg21/ for the official
  list.</EM></P>
<P>2024-12-19</P>
<HR>
<A NAME="346"></A><H4>346.
  
Typo in 15.4
</H4>
<B>Section: </B>14.5&#160; [<A href="https://wg21.link/except.spec">except.spec</A>]
 &#160;&#160;&#160;

 <B>Status: </B>NAD
 &#160;&#160;&#160;

 <B>Submitter: </B>Lois Goldthwaite
 &#160;&#160;&#160;

 <B>Date: </B>18 March 2002<BR>


<P>14.5 [<A href="https://wg21.link/except.spec#13">except.spec</A>] paragraph 13 contains the following text.
I believe 'implicitLY' marked below should be replaced with
'implicit.'</P>
<BLOCKQUOTE>
<P>An implicitly declared special member
 function (11.4.4 [<A href="https://wg21.link/special">special</A>])
shall have an exception-specification. If f is an implicitly
declared default constructor, copy constructor, destructor, or copy
assignment operator, its implicit exception-specification
specifies the <I>type-id</I> T if and only if T is allowed by the
exception-specification of a function directly invoked
by f's <INS>implicitly</INS> definition;
f shall allow all exceptions if any function it directly invokes
allows all exceptions, and f shall allow no exceptions if
every function it directly invokes allows no exceptions. [Example: </P>
<PRE>
    struct A {
        A();
        A(const A&amp;) throw();
        ~A() throw(X);
    };
    struct B {
        B() throw();
        B(const B&amp;) throw();
        ~B() throw(Y);
    };
    struct D : public A, public B {
            //  Implicit declaration of  D::D();
            //  Implicit declaration of  D::D(const   D&amp;)   throw();
            //  Implicit declaration of  D::~D()   throw   (X,Y);
    };
</PRE>

<P>Furthermore, if A::~A() or B::~B() were virtual, D::~D() would not be as
restrictive as that of A::~A, and the program would
be ill-formed since a function that overrides a virtual function from a
base class shall have an exception-specification at least as
restrictive as that in the base class. ] </P>
</BLOCKQUOTE>

<P>The example code shows structs whose destructors have exception
specifications which throw certain types. There is no defect here, but
it doesn't sit well with our general advice elsewhere that destructors
should not throw. I wish I could think of some other way to illustrate
this section.</P>

<P><B>Notes from October 2002 meeting:</B></P>

<P>This was previously resolved by an editorial change.</P>

<BR><BR>
</BODY>
</HTML>
