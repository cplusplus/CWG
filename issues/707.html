<HTML>
<HEAD>
<meta http-equiv="Content-Type" content="text/html; charset=us-ascii">
<TITLE>
    CWG Issue 707</TITLE>
<STYLE TYPE="text/css">
  INS { text-decoration:none; font-weight:bold; background-color:#A0FFA0 }
  .INS { text-decoration:none; background-color:#D0FFD0 }
  DEL { text-decoration:line-through; background-color:#FFA0A0 }
  .DEL { text-decoration:line-through; background-color: #FFD0D0 }
  SPAN.cmnt { font-family:Times; font-style:italic }
</STYLE>
</HEAD>
<BODY>
<P><EM>This is an unofficial snapshot of the ISO/IEC JTC1 SC22 WG21
  Core Issues List revision 116b.
  See http://www.open-std.org/jtc1/sc22/wg21/ for the official
  list.</EM></P>
<P>2025-03-05</P>
<HR>
<A NAME="707"></A><H4>707.
  
Undefined behavior in integral-to-floating conversions
</H4>
<B>Section: </B>7.3.11&#160; [<A href="https://wg21.link/conv.fpint">conv.fpint</A>]
 &#160;&#160;&#160;

 <B>Status: </B>CD2
 &#160;&#160;&#160;

 <B>Submitter: </B>Alberto Ganesh Barbati
 &#160;&#160;&#160;

 <B>Date: </B>2 Aug, 2008<BR>


<P>[Voted into WP at July, 2009 meeting.]</P>



<P>The current wording of 7.3.11 [<A href="https://wg21.link/conv.fpint#2">conv.fpint</A>] paragraph 2
does not specify what should happen when converting an integer
value that is outside the representable range of the target floating
point type.  The C99 Standard covers this case explicitly in
6.3.1.4 paragraph 2:</P>

<BLOCKQUOTE>

When a value of integer type is converted to a real floating
type, if the value being converted can be represented exactly in
the new type, it is unchanged.  If the value being converted is
in the range of values that can be represented but cannot be
represented exactly, the result is either the nearest higher or
nearest lower representable value, chosen in an
implementation-defined manner.  If the value being converted is
outside the range of values that can be represented, the behavior
is undefined.

</BLOCKQUOTE>

<P>While the current C++ specification requires defined behavior
in all cases, the C specification allows for use of NaNs and
traps, if those are needed for efficiency.</P>

<P><B>Notes from the September, 2008 meeting:</B></P>

<P>The CWG agreed that the C approach should be adopted.</P>

<P><B>Proposed resolution (March, 2009):</B></P>

<P>Change 7.3.11 [<A href="https://wg21.link/conv.fpint#2">conv.fpint</A>] paragraph 2 as indicated:</P>

<BLOCKQUOTE>

An rvalue of an integer type or of an unscoped enumeration type can be
converted to an rvalue of a floating point type.  The result is exact
if possible.  <DEL>Otherwise</DEL> <INS>If the value being converted is in
the range of values that can be represented but cannot be represented
exactly</INS>, it is an implementation-defined choice of
either the next lower or higher representable value.  [<I>Note:</I>
loss of precision occurs if the integral value cannot be represented
exactly as a value of the floating type.  &#8212;<I>end note</I>]
<INS>If the value being converted is outside the range of values that
can be represented, the behavior is undefined.</INS> If the source type
is <TT>bool</TT>, the value <TT>false</TT> is converted to zero and
the value <TT>true</TT> is converted to one.

</BLOCKQUOTE>

<BR><BR>
</BODY>
</HTML>
