<HTML>
<HEAD>
<meta http-equiv="Content-Type" content="text/html; charset=us-ascii">
<TITLE>
    CWG Issue 182</TITLE>
<STYLE TYPE="text/css">
  INS { text-decoration:none; font-weight:bold; background-color:#A0FFA0 }
  .INS { text-decoration:none; background-color:#D0FFD0 }
  DEL { text-decoration:line-through; background-color:#FFA0A0 }
  .DEL { text-decoration:line-through; background-color: #FFD0D0 }
  SPAN.cmnt { font-family:Times; font-style:italic }
</STYLE>
</HEAD>
<BODY>
<P><EM>This is an unofficial snapshot of the ISO/IEC JTC1 SC22 WG21
  Core Issues List revision 116a.
  See http://www.open-std.org/jtc1/sc22/wg21/ for the official
  list.</EM></P>
<P>2024-12-19</P>
<HR>
<A NAME="182"></A><H4>182.
  
Access checking on explicit specializations
</H4>
<B>Section: </B>13.9.4&#160; [<A href="https://wg21.link/temp.expl.spec">temp.expl.spec</A>]
 &#160;&#160;&#160;

 <B>Status: </B>NAD
 &#160;&#160;&#160;

 <B>Submitter: </B>John Spicer
 &#160;&#160;&#160;

 <B>Date: </B>8 Nov 1999<BR>





<P>
<U>John Spicer</U>:
Certain access checks are suppressed on explicit instantiations.
13.9.3 [<A href="https://wg21.link/temp.explicit#8">temp.explicit</A>] paragraph 8

says:</P>

<BLOCKQUOTE>
The usual access checking rules do not apply to names used to specify
explicit instantiations. [<I>Note:</I> In particular, the template arguments
and names used in the function declarator (including parameter types,
return types and exception specifications) may be private types or
objects which would normally not be accessible and the template may be
a member template or member function which would not normally be
accessible. ]
</BLOCKQUOTE>

I was surprised that similar wording does not exist (that I could find) for
explicit specializations.  I believe that the two cases should be handled
equivalently in the example below (i.e., that the specialization should be
permitted).

<PRE>
    template &lt;class T&gt; struct C {
    void f();
    void g();
    };

    template &lt;class T&gt; void C&lt;T&gt;::f(){}
    template &lt;class T&gt; void C&lt;T&gt;::g(){}

    class A {
    class B {};
    void f();
    };

    template void C&lt;A::B&gt;::f();    // okay
    template &lt;&gt; void C&lt;A::B&gt;::g(); // error - A::B inaccessible

    void A::f() {
    C&lt;B&gt; cb;
    cb.f();
    }
</PRE>

<P>
<U>Mike Miller</U>:
According to the note in
13.4 [<A href="https://wg21.link/temp.arg#3">temp.arg</A>] paragraph 3,
</P>

<BLOCKQUOTE>
if the name of a <I>template-argument</I> is accessible
at the point where it is used as a <I>template-argument</I>,
there is no further access restriction in the
resulting instantiation where the corresponding
<I>template-parameter</I> name is used.
</BLOCKQUOTE>

<P>(Is this specified anywhere in the normative text?  Should
it be?)</P>

<P>In the absence of text to the contrary, this blanket
permission apparently applies to explicitly-specialized
templates as well as to implicitly-generated ones (is that
right?).  If so, I don't see any reason that an explicit
instantiation should be treated differently from an explicit
specialization, even though the latter involves new program
text and the former is just a placement instruction to the
implementation.</P>

<P><B>Proposed Resolution (4/02):</B></P>

<P>In 13.9.3 [<A href="https://wg21.link/temp.explicit">temp.explicit</A>] delete paragraph 8:</P>
<BLOCKQUOTE>
The usual access checking rules do not apply to names used to specify explicit
instantiations. [Note: In particular, the template arguments and names used in
the function declarator (including parameter types, return types and exception
specifications) may be private types or objects which would normally not be
accessible and the template may be a member template or member function which
would not normally be accessible. ]
</BLOCKQUOTE>

<P>In 13.9 [<A href="https://wg21.link/temp.spec">temp.spec</A>] add the paragraph deleted above as
paragraph 7 with the changes highlighted below:</P>

<BLOCKQUOTE>
The usual access checking rules do not apply to names used to specify explicit
instantiations <INS>or explicit specializations</INS>. <DEL>[Note: In
particular, t</DEL><INS>T</INS>he template arguments and names used in the
function declarator (including parameter types, return types and exception
specifications) may be private types or objects which would normally not be
accessible and the template may be a member template or member function
which would not normally be accessible. <DEL>]</DEL>
</BLOCKQUOTE>

<P><B>Rationale (October 2002):</B></P>

<P>We reconsidered this and decided that the difference between the
two cases (explicit specialization and explicit instantiation) is
appropriate.  The access rules are sometimes bent when necessary to
allow naming something, as in an explicit instantiation, but
explicit specialization requires not only naming the entity but
also providing a definition somewhere.</P>

<BR><BR>
</BODY>
</HTML>
