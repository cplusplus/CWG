<HTML>
<HEAD>
<meta http-equiv="Content-Type" content="text/html; charset=us-ascii">
<TITLE>
    CWG Issue 1483</TITLE>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<STYLE TYPE="text/css">
  INS { text-decoration:none; font-weight:bold; background-color:#A0FFA0 }
  .INS { text-decoration:none; background-color:#D0FFD0 }
  DEL { text-decoration:line-through; background-color:#FFA0A0 }
  .DEL { text-decoration:line-through; background-color: #FFD0D0 }
  @media (prefers-color-scheme: dark) {
    HTML { background-color:#202020; color:#f0f0f0; }
    A { color:#5bc0ff; }
    A:visited { color:#c6a8ff; }
    A:hover, a:focus { color:#afd7ff; }
    INS { background-color:#033a16; color:#aff5b4; }
    .INS { background-color: #033a16; }
    DEL { background-color:#67060c; color:#ffdcd7; }
    .DEL { background-color:#67060c; }
  }
  SPAN.cmnt { font-family:Times; font-style:italic }
</STYLE>
</HEAD>
<BODY>
<P><EM>This is an unofficial snapshot of the ISO/IEC JTC1 SC22 WG21
  Core Issues List revision 116c.
  See http://www.open-std.org/jtc1/sc22/wg21/ for the official
  list.</EM></P>
<P>2025-03-08</P>
<HR>
<A NAME="1483"></A><H4>1483.
  
Non-dependent <I>static_assert-declaration</I>s
</H4>
<B>Section: </B>13.8&#160; [<A href="https://wg21.link/temp.res">temp.res</A>]
 &#160;&#160;&#160;

 <B>Status: </B>NAD
 &#160;&#160;&#160;

 <B>Submitter: </B>Mike Miller
 &#160;&#160;&#160;

 <B>Date: </B>2012-03-23<BR>


<P>Recently a customer sent us code of the form,</P>

<PRE>
  template&lt;typename T&gt; void f();
  template&lt;&gt; void f&lt;int&gt;() { }
  template&lt;typename T&gt; void f() {
    static_assert(false, "f() instantiated with non-int type.");
  }
</PRE>

<P>The intent, obviously, was to do compile-time diagnosis of
specializations of the template that were not supported, and code of
this form is supported by at least some implementations. However,
the current wording of 13.8 [<A href="https://wg21.link/temp.res#8">temp.res</A>] paragraph 8,
appears to invalidate this approach:</P>

<BLOCKQUOTE>

If no valid specialization can be generated for a template, and that
template is not instantiated, the template is ill-formed, no
diagnostic required.

</BLOCKQUOTE>

<P>In this example, the <TT>static_assert</TT> will fail for every
generated specialization of <TT>f()</TT>, so an implementation can
issue the error, regardless of whether <TT>f()</TT> is ever
instantiated with a non-<TT>int</TT> type or not.</P>

<P>A relatively straightforward but somewhat ugly workaround is to
define a template like</P>

<PRE>
  template&lt;typename&gt; struct always_false {
    static const bool val = false;
  };
</PRE>

<P>and replace the use of <TT>false</TT> in the <TT>static_assert</TT>
with <TT>always_false&lt;T&gt;::val</TT>, making the <TT>static_assert</TT>
dependent.</P>

<P>Considering the fact that a non-dependent
<I>static_assert-declaration</I> in a template is otherwise pretty
useless, however, it might be worth considering whether to support
this usage somehow, especially in light of the fact that it is
supported by some implementations, perhaps by treating
<I>static_assert-declaration</I>s as always dependent, even if the
condition is not otherwise dependent.</P>

<P><B>Rationale (October, 2012):</B></P>

<P>Although this usage is supported by some implementations and used
in some libraries, CWG felt that <TT>=delete</TT> is the appropriate
mechanism for making a function template or member function of a class
template unavailable for specialization.</P>

<BR><BR>
</BODY>
</HTML>
