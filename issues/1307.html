<HTML>
<HEAD>
<meta http-equiv="Content-Type" content="text/html; charset=us-ascii">
<TITLE>
    CWG Issue 1307</TITLE>
<STYLE TYPE="text/css">
  INS { text-decoration:none; font-weight:bold; background-color:#A0FFA0 }
  .INS { text-decoration:none; background-color:#D0FFD0 }
  DEL { text-decoration:line-through; background-color:#FFA0A0 }
  .DEL { text-decoration:line-through; background-color: #FFD0D0 }
  SPAN.cmnt { font-family:Times; font-style:italic }
</STYLE>
</HEAD>
<BODY>
<P><EM>This is an unofficial snapshot of the ISO/IEC JTC1 SC22 WG21
  Core Issues List revision 116.
  See http://www.open-std.org/jtc1/sc22/wg21/ for the official
  list.</EM></P>
<P>2024-12-19</P>
<HR>
<A NAME="1307"></A><H4>1307.
  
Overload resolution based on size of array <I>initializer-list</I>
</H4>
<B>Section: </B>12.2.4.2.6&#160; [<A href="https://wg21.link/over.ics.list">over.ics.list</A>]
 &#160;&#160;&#160;

 <B>Status: </B>C++14
 &#160;&#160;&#160;

 <B>Submitter: </B>Johannes Schaub
 &#160;&#160;&#160;

 <B>Date: </B>2011-04-30<BR>


<P>[Moved to DR at the September, 2013 meeting.]</P>



<P>In an example like</P>

<PRE>
  void f(int const(&amp;)[2]);
  void f(int const(&amp;)[3]);

  int main() {
   f({1, 2, 3});
  }
</PRE>

<P>the current overload resolution rules make no provision for different
array sizes and thus treats the call as ambiguous, even though it seems
obvious that the second <TT>f</TT> should be chosen in this case.</P>

<P><B>Rationale (August, 2011):</B></P>

<P>The implications of array temporaries for the language should be
considered by the Evolution Working Group in a comprehensive fashion
rather than on a case-by-case basis.  See also issues
<A HREF="1300.html">1300</A>, <A HREF="1326.html">1326</A>,
and <A HREF="1525.html">1525</A>.</P>

<P><B>Notes from the October, 2012 meeting:</B></P>

<P>CWG determined that this issue is unrelated to array temporaries
and that a tiebreaker should be added for this case in overload
resolution.</P>

<P><B>Proposed resolution, April, 2013:</B></P>

<OL>
<LI><P>Change 12.2.4.2.6 [<A href="https://wg21.link/over.ics.list#2">over.ics.list</A>] paragraph 2 as
follows, adding a new paragraph (and moving the footnote to the new
paragraph, as indicated):</P></LI>

<BLOCKQUOTE>

<P>If the parameter type
is <TT>std::initializer_list&lt;X&gt;</TT> <DEL>or
&#8220;array of X&#8221; [<I>Footnote:</I> Since there are
no parameters of array type, this will only occur as the
underlying type of a reference parameter. &#8212;<I>end
footnote</I>]</DEL> and all the elements of the initializer
list can be implicitly converted to <TT>X</TT>, the implicit
conversion sequence is the worst conversion necessary to
convert an element of the list to <TT>X</TT>. This
conversion can be a user-defined conversion even in the
context of a call to an initializer-list
constructor. [<I>Example:</I> ...  &#8212;<I>end
example</I>]</P>

<P><INS>Otherwise, if the parameter type is &#8220;array
of <TT>N</TT> <TT>X</TT>&#8221; [<I>Footnote:</I> Since
there are no parameters of array type, this will only occur
as the underlying type of a reference
parameter. &#8212;<I>end footnote</I>], if the initializer
list has exactly <TT>N</TT> elements or if it has fewer than <TT>N</TT>
elements and <TT>X</TT> is default-constructible, and if all the
elements of the initializer list can be implicitly converted
to <TT>X</TT>, the implicit conversion sequence is the worst
conversion necessary to convert an element of the list to
<TT>X</TT>.</INS></P>

</BLOCKQUOTE>

<I>[Drafting note: no other case in the remainder of the paragraph
applies when the initializer list has more elements than the parameter
array.]</I>

<LI><P>Change 12.2.4.3 [<A href="https://wg21.link/over.ics.rank#3">over.ics.rank</A>] paragraph 3 as follows:</P></LI>

<BLOCKQUOTE>

<P>Two implicit conversion sequences of the same form are
indistinguishable conversion sequences unless one of the
following rules applies:</P>

<UL>
<LI><P>...</P></LI>

<LI><P>List-initialization sequence <TT>L1</TT> is a better
conversion sequence than list-initialization
sequence <TT>L2</TT> if <DEL><TT>L1</TT> converts
to <TT>std::initializer_list&lt;X&gt;</TT> for
some <TT>X</TT> and <TT>L2</TT> does not.</DEL>
</P></LI>

<UL>
<LI><P><INS><TT>L1</TT> converts to
<TT>std::initializer_list&lt;X&gt;</TT> for some <TT>X</TT> and
<TT>L2</TT> does not, or, if not that,</INS></P></LI>

<LI>

<P><INS><TT>L1</TT> converts to type &#8220;array
of <TT>N1</TT> <TT>T</TT>,&#8221; <TT>L2</TT> converts to
type &#8220;array of <TT>N2</TT> <TT>T</TT>&#8221;,
and <TT>N1</TT> is smaller than <TT>N2</TT>.</INS></P>
</LI>

</UL>

</UL>

</BLOCKQUOTE>

</OL>

<BR><BR>
</BODY>
</HTML>
