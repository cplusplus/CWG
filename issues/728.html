<HTML>
<HEAD>
<meta http-equiv="Content-Type" content="text/html; charset=us-ascii">
<TITLE>
    CWG Issue 728</TITLE>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<STYLE TYPE="text/css">
  INS { text-decoration:none; font-weight:bold; background-color:#A0FFA0 }
  .INS { text-decoration:none; background-color:#D0FFD0 }
  DEL { text-decoration:line-through; background-color:#FFA0A0 }
  .DEL { text-decoration:line-through; background-color: #FFD0D0 }
  @media (prefers-color-scheme: dark) {
    HTML { background-color:#202020; color:#f0f0f0; }
    A { color:#5bc0ff; }
    A:visited { color:#c6a8ff; }
    A:hover, a:focus { color:#afd7ff; }
    INS { background-color:#033a16; color:#aff5b4; }
    .INS { background-color: #033a16; }
    DEL { background-color:#67060c; color:#ffdcd7; }
    .DEL { background-color:#67060c; }
  }
  SPAN.cmnt { font-family:Times; font-style:italic }
</STYLE>
</HEAD>
<BODY>
<P><EM>This is an unofficial snapshot of the ISO/IEC JTC1 SC22 WG21
  Core Issues List revision 116c.
  See http://www.open-std.org/jtc1/sc22/wg21/ for the official
  list.</EM></P>
<P>2025-03-08</P>
<HR>
<A NAME="728"></A><H4>728.
  
Restrictions on local classes
</H4>
<B>Section: </B>Clause 13&#160; [<A href="https://wg21.link/temp">temp</A>]
 &#160;&#160;&#160;

 <B>Status: </B>NAD
 &#160;&#160;&#160;

 <B>Submitter: </B>Faisal Vali
 &#160;&#160;&#160;

 <B>Date: </B>5 October, 2008<BR>


<P>Now that the restriction against local classes being used as
template arguments has been lifted, they are more useful, yet they are
still crippled.  For some reason or oversight, the restriction against
local classes being templates or having member templates was not
lifted.  Allowing local classes to have member templates facilitates
generic programming (the reason for lifting the other restriction),
especially when it comes to the visitor-pattern (see the
<TT>boost::variant</TT> documentation and the following example) as
implemented in boost and the <TT>boost::MPL</TT> library (since
functors have to be template classes in mpl, and higher-order functors
have to have member templates to be useful).  A local class with a
member template would allow this desirable solution:</P>

<PRE>
    #include &lt;boost/variant.hpp&gt;
    int main() {
      struct times_two_generic: public boost::static_visitor&lt;&gt; {
        template &lt;typename T&gt; void operator()(T&amp; operand) const {
            operand += operand;
        }
      };

      std::vector&lt;boost::variant&lt;int, std::string&gt;&gt; vec;
      vec.push_back(21);
      vec.push_back("hello ");

      times_two_generic visitor;
      std::for_each(vec.begin(), vec.end(), boost::apply_visitor(visitor));
    }
</PRE>

<P>Is there any compelling reason not to allow this code?  Is there
any compelling reason not to allow local classes to be templates, have
friends, or be able to define their static data members at function
scope?  Wouldn't this symmetry amongst local and non-local classes
make the language more appealing and less embarrassing?</P>

<P><B>Rationale (June, 2021):</B></P>

<P>EWG resolved to pursue this topic with paper P2044.
It is no longer tracked as a core issue.
See <A HREF="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p1018r11.html#CWG728">vote</A>.</P>

<BR><BR>
</BODY>
</HTML>
