<HTML>
<HEAD>
<meta http-equiv="Content-Type" content="text/html; charset=us-ascii">
<TITLE>
    CWG Issue 2742</TITLE>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<STYLE TYPE="text/css">
  INS { text-decoration:none; font-weight:bold; background-color:#A0FFA0 }
  .INS { text-decoration:none; background-color:#D0FFD0 }
  DEL { text-decoration:line-through; background-color:#FFA0A0 }
  .DEL { text-decoration:line-through; background-color: #FFD0D0 }
  @media (prefers-color-scheme: dark) {
    HTML { background-color:#202020; color:#f0f0f0; }
    A { color:#5bc0ff; }
    A:visited { color:#c6a8ff; }
    A:hover, a:focus { color:#afd7ff; }
    INS { background-color:#033a16; color:#aff5b4; }
    .INS { background-color: #033a16; }
    DEL { background-color:#67060c; color:#ffdcd7; }
    .DEL { background-color:#67060c; }
  }
  SPAN.cmnt { font-family:Times; font-style:italic }
</STYLE>
</HEAD>
<BODY>
<P><EM>This is an unofficial snapshot of the ISO/IEC JTC1 SC22 WG21
  Core Issues List revision 116c.
  See http://www.open-std.org/jtc1/sc22/wg21/ for the official
  list.</EM></P>
<P>2025-03-08</P>
<HR>
<A NAME="2742"></A><H4>2742.
  
Guaranteed copy elision for brace-initialization from prvalue
</H4>
<B>Section: </B>9.4.5&#160; [<A href="https://wg21.link/dcl.init.list">dcl.init.list</A>]
 &#160;&#160;&#160;

 <B>Status: </B>drafting
 &#160;&#160;&#160;

 <B>Submitter: </B>Jim X
 &#160;&#160;&#160;

 <B>Date: </B>2023-06-06<BR>


<P>Consider:</P>

<PRE>
  struct A {
    A();
    A(A const&amp;) = delete;
  };
  int main(){
    A a = A(A(A())); //<SPAN CLASS="cmnt"> #1 </SPAN>
    A b = A{A{A{}}}; //<SPAN CLASS="cmnt"> #2 </SPAN>
  }
</PRE>

<P>#1 is well-formed per 9.4.1 [<A href="https://wg21.link/dcl.init.general#16.6.1">dcl.init.general</A>] bullet 16.6.1.
However, even though #2 is intended to have a similar effect, the
relevant rule excludes non-aggregates, making the example ill-formed
(because the relevant constructor is deleted); see
9.4.5 [<A href="https://wg21.link/dcl.init.list#3.2">dcl.init.list</A>] bullet 3.2:</P>

<BLOCKQUOTE>

If T is an aggregate class and the initializer list has a single
element of type cv U, where U is T or a class derived from T, the
object is initialized from that element (by copy-initialization for
copy-list-initialization, or by direct-initialization for
direct-list-initialization).

</BLOCKQUOTE>

<P>There is implementation divergence: gcc and clang accept, MSVC rejects.</P>

<P>See also <A HREF="2311.html">issue 2311</A>.</P>

<P><U>Suggested resolution:</U></P>

<P>Change in 9.4.5 [<A href="https://wg21.link/dcl.init.list#3.2">dcl.init.list</A>] bullet 3.2 as follows:</P>

<BLOCKQUOTE>

If T is <DEL>an aggregate class</DEL> <INS>a class type</INS> and the
initializer list has a single element of type cv U, where U is T or a
class derived from T, the object is initialized from that element (by
copy-initialization for copy-list-initialization, or by
direct-initialization for direct-list-initialization).

</BLOCKQUOTE>

<P><B>CWG 2024-03-01</B></P>

<P>Recent MSVC no longer rejects the example.  The suggested
resolution would revert <A HREF="2137.html">issue 2137</A>, which
is not desirable.  The consensus is to try an initializer-list
constructor first and then fall back to copy-initialization (with
guaranteed copy elision).  A change to 12.2.4.2.6 [<A href="https://wg21.link/over.ics.list">over.ics.list</A>]
may be necessary.</P>

<BR><BR>
</BODY>
</HTML>
