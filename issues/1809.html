<HTML>
<HEAD>
<meta http-equiv="Content-Type" content="text/html; charset=us-ascii">
<TITLE>
    CWG Issue 1809</TITLE>
<STYLE TYPE="text/css">
  INS { text-decoration:none; font-weight:bold; background-color:#A0FFA0 }
  .INS { text-decoration:none; background-color:#D0FFD0 }
  DEL { text-decoration:line-through; background-color:#FFA0A0 }
  .DEL { text-decoration:line-through; background-color: #FFD0D0 }
  SPAN.cmnt { font-family:Times; font-style:italic }
</STYLE>
</HEAD>
<BODY>
<P><EM>This is an unofficial snapshot of the ISO/IEC JTC1 SC22 WG21
  Core Issues List revision 116a.
  See http://www.open-std.org/jtc1/sc22/wg21/ for the official
  list.</EM></P>
<P>2024-12-19</P>
<HR>
<A NAME="1809"></A><H4>1809.
  
Narrowing and template argument deduction
</H4>
<B>Section: </B>13.10.3&#160; [<A href="https://wg21.link/temp.deduct">temp.deduct</A>]
 &#160;&#160;&#160;

 <B>Status: </B>CD4
 &#160;&#160;&#160;

 <B>Submitter: </B>Richard Smith
 &#160;&#160;&#160;

 <B>Date: </B>2013-11-12<BR>


<P>[Moved to DR at the November, 2014 meeting.]</P>



<P>13.10.3 [<A href="https://wg21.link/temp.deduct#9">temp.deduct</A>] paragraph 9 reads,</P>

<BLOCKQUOTE>

<P>Except as described above, the use of an invalid value shall
not cause type deduction to fail. [<I>Example:</I> In the
following example 1000 is converted to <TT>signed char</TT> and
results in an implementation-defined value as specified in
(7.3.9 [<A href="https://wg21.link/conv.integral">conv.integral</A>]). In other words, both templates
are considered even though 1000, when converted to <TT>signed
char</TT>, results in an implementation-defined value.</P>

<PRE>
  template &lt;int&gt; int f(int);
  template &lt;signed char&gt; int f(int);
  int i1 = f&lt;1&gt;(0);      //<SPAN CLASS="cmnt"> ambiguous</SPAN>
  int i2 = f&lt;1000&gt;(0);   //<SPAN CLASS="cmnt"> ambiguous</SPAN>
</PRE>

<P>&#8212;<I>end example</I>]</P>

</BLOCKQUOTE>

<P>This is no longer correct, even ignoring the fact that
some implementations may be able to represent the value 1000
as a <TT>signed char</TT>: integral and enumeration
non-type template arguments are now converted constant
expressions (13.4.3 [<A href="https://wg21.link/temp.arg.nontype#1">temp.arg.nontype</A>] paragraph 1), and
converted constant expressions disallow narrowing conversions
(7.7 [<A href="https://wg21.link/expr.const#3">expr.const</A>] paragraph 3).</P>

<P><B>Proposed resolution (February, 2014):</B></P>

<P>Change 13.10.3 [<A href="https://wg21.link/temp.deduct#9">temp.deduct</A>] paragraph 9 as follows:</P>

<BLOCKQUOTE>

<P>
<DEL>Except as described above, the use of an invalid value shall not
cause type deduction to fail.</DEL> [<I>Example:</I> In the following
example<INS>,</INS> <DEL>1000 is converted to signed char and results in an
implementation-defined value as specified in (7.3.9 [<A href="https://wg21.link/conv.integral">conv.integral</A>]). In
other words, both templates are considered even though 1000, when converted
to signed char, results in an implementation-defined value</DEL>
<INS>assuming a <TT>signed char</TT> cannot represent the value 1000, a
narrowing conversion would be required to convert the <I>template-argument</I>
of type <TT>int</TT> to <TT>signed char</TT>, therefore substitution fails
for the second template (13.4.3 [<A href="https://wg21.link/temp.arg.nontype">temp.arg.nontype</A>]).</INS>.</P>

<PRE>
  template &lt;int&gt; int f(int);
  template &lt;signed char&gt; int f(int);
  int i1 = f&lt;1<INS>000</INS>&gt;(0);       //<SPAN CLASS="cmnt"> <DEL>ambiguous</DEL> <INS>OK</INS></SPAN>
  int i2 = f&lt;1<DEL>000</DEL>&gt;(0);       //<SPAN CLASS="cmnt"> ambiguous<INS>; not narrowing</INS></SPAN>
</PRE>

<P>&#8212;<I>end example</I>]</P>

</BLOCKQUOTE>

<BR><BR>
</BODY>
</HTML>
