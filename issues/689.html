<HTML>
<HEAD>
<meta http-equiv="Content-Type" content="text/html; charset=us-ascii">
<TITLE>
    CWG Issue 689</TITLE>
<STYLE TYPE="text/css">
  INS { text-decoration:none; font-weight:bold; background-color:#A0FFA0 }
  .INS { text-decoration:none; background-color:#D0FFD0 }
  DEL { text-decoration:line-through; background-color:#FFA0A0 }
  .DEL { text-decoration:line-through; background-color: #FFD0D0 }
  SPAN.cmnt { font-family:Times; font-style:italic }
</STYLE>
</HEAD>
<BODY>
<P><EM>This is an unofficial snapshot of the ISO/IEC JTC1 SC22 WG21
  Core Issues List revision 116a.
  See http://www.open-std.org/jtc1/sc22/wg21/ for the official
  list.</EM></P>
<P>2024-12-19</P>
<HR>
<A NAME="689"></A><H4>689.
  
Maximum values of signed and unsigned integers
</H4>
<B>Section: </B>6.8.2&#160; [<A href="https://wg21.link/basic.fundamental">basic.fundamental</A>]
 &#160;&#160;&#160;

 <B>Status: </B>CD5
 &#160;&#160;&#160;

 <B>Submitter: </B>James Kanze
 &#160;&#160;&#160;

 <B>Date: </B>30 March, 2008<BR>


<P>[Resolved by paper P1236R1, adopted at the November, 2018 meeting.]</P>



<P>The relationship between the values representable by corresponding
signed and unsigned integer types is not completely described, but
6.8 [<A href="https://wg21.link/basic.types#4">basic.types</A>] paragraph 4 says,</P>

<BLOCKQUOTE>

The <I>value representation</I> of an object is the set of bits that
hold the value of type <TT>T</TT>.

</BLOCKQUOTE>

<P>and 6.8.2 [<A href="https://wg21.link/basic.fundamental#3">basic.fundamental</A>] paragraph 3 says,</P>

<BLOCKQUOTE>

The range of nonnegative values of a signed integer type is a
subrange of the corresponding unsigned integer type, and the
value representation of each corresponding signed/unsigned type
shall be the same.

</BLOCKQUOTE>

<P>I.e., the maximum value of each unsigned type must be larger
than the maximum value of the corresponding signed type.</P>

<P>C90 doesn't have this restriction, and C99 explicitly says
(6.2.6.2, paragraph 2),</P>

<BLOCKQUOTE>

For signed integer types, the bits of the object representation
shall be divided into three groups: value bits, padding bits, and
the sign bit. There need not be any padding bits; there shall be
exactly one sign bit. Each bit that is a value bit shall have the
same value as the same bit in the object representation of the
corresponding unsigned type (if there are <I>M</I> value bits in the
signed type and N in the unsigned type, then <I>M</I> &lt;= <I>N</I>).

</BLOCKQUOTE>

<P>Unlike C++, the sign bit is not part of the value, and on an
architecture that does not have native support of unsigned types,
an implementation can emulate unsigned integers by simply
ignoring what would be the sign bit in the signed type and be
conforming.</P>

<P>The question is whether we intend to make a conforming
implementation on such an architecture impossible. More
generally, what range of architectures do we intend to
support?  And to what degree do we want to follow C99 in
its evolution since C89?</P>

<P>(See paper J16/08-0141 = WG21 N2631.)</P>

<BR><BR>
</BODY>
</HTML>
