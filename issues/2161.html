<HTML>
<HEAD>
<meta http-equiv="Content-Type" content="text/html; charset=us-ascii">
<TITLE>
    CWG Issue 2161</TITLE>
<STYLE TYPE="text/css">
  INS { text-decoration:none; font-weight:bold; background-color:#A0FFA0 }
  .INS { text-decoration:none; background-color:#D0FFD0 }
  DEL { text-decoration:line-through; background-color:#FFA0A0 }
  .DEL { text-decoration:line-through; background-color: #FFD0D0 }
  SPAN.cmnt { font-family:Times; font-style:italic }
</STYLE>
</HEAD>
<BODY>
<P><EM>This is an unofficial snapshot of the ISO/IEC JTC1 SC22 WG21
  Core Issues List revision 116a.
  See http://www.open-std.org/jtc1/sc22/wg21/ for the official
  list.</EM></P>
<P>2024-12-19</P>
<HR>
<A NAME="2161"></A><H4>2161.
  
Explicit instantiation declaration and &#8220;preceding initialization&#8221;
</H4>
<B>Section: </B>13.9.3&#160; [<A href="https://wg21.link/temp.explicit">temp.explicit</A>]
 &#160;&#160;&#160;

 <B>Status: </B>NAD
 &#160;&#160;&#160;

 <B>Submitter: </B>Hubert Tong
 &#160;&#160;&#160;

 <B>Date: </B>2015-07-22<BR>




<P>Consider the following example:</P>

<PRE>
  template &lt;typename T&gt; extern const decltype(sizeof 0) Sz = sizeof(T);
  extern template const decltype(sizeof 0) Sz&lt;int&gt;;

  constexpr decltype(sizeof 0) x = Sz&lt;int&gt;;
</PRE>

<P>C++14 allows this, exempting &#8220;const variables of
literal type" from the effects of an explicit instantiation
declaration:</P>

<BLOCKQUOTE>

Except for inline functions, declarations with types deduced
from their initializer or return value
(9.2.9.7 [<A href="https://wg21.link/dcl.spec.auto">dcl.spec.auto</A>]), const variables of literal
types, variables of reference types, and class template
specializations, explicit instantiation declarations have
the effect of suppressing the implicit instantiation of the
entity to which they refer. [<I>Note:</I> The intent is that
an inline function that is the subject of an explicit
instantiation declaration will still be implicitly
instantiated when odr-used (6.3 [<A href="https://wg21.link/basic.def.odr">basic.def.odr</A>]) so
that the body can be considered for inlining, but that no
out-of-line copy of the inline function would be generated
in the translation unit. &#8212;<I>end note</I>]

</BLOCKQUOTE>

<P>Should there be a DR against C++11 for the similar case of
a static data member of a class template?</P>

<P><B>Rationale (October, 2015):</B></P>

<P>CWG agreed that this was a defect in C++11, but it is
addressed in C++14.</P>

<BR><BR>
</BODY>
</HTML>
