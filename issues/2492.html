<HTML>
<HEAD>
<meta http-equiv="Content-Type" content="text/html; charset=us-ascii">
<TITLE>
    CWG Issue 2492</TITLE>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<STYLE TYPE="text/css">
  INS { text-decoration:none; font-weight:bold; background-color:#A0FFA0 }
  .INS { text-decoration:none; background-color:#D0FFD0 }
  DEL { text-decoration:line-through; background-color:#FFA0A0 }
  .DEL { text-decoration:line-through; background-color: #FFD0D0 }
  @media (prefers-color-scheme: dark) {
    HTML { background-color:#202020; color:#f0f0f0; }
    A { color:#5bc0ff; }
    A:visited { color:#c6a8ff; }
    A:hover, a:focus { color:#afd7ff; }
    INS { background-color:#033a16; color:#aff5b4; }
    .INS { background-color: #033a16; }
    DEL { background-color:#67060c; color:#ffdcd7; }
    .DEL { background-color:#67060c; }
  }
  SPAN.cmnt { font-family:Times; font-style:italic }
</STYLE>
</HEAD>
<BODY>
<P><EM>This is an unofficial snapshot of the ISO/IEC JTC1 SC22 WG21
  Core Issues List revision 116c.
  See http://www.open-std.org/jtc1/sc22/wg21/ for the official
  list.</EM></P>
<P>2025-03-08</P>
<HR>
<A NAME="2492"></A><H4>2492.
  
Comparing user-defined conversion sequences in list-initialization
</H4>
<B>Section: </B>12.2.4.2.6&#160; [<A href="https://wg21.link/over.ics.list">over.ics.list</A>]
 &#160;&#160;&#160;

 <B>Status: </B>open
 &#160;&#160;&#160;

 <B>Submitter: </B>Jim X
 &#160;&#160;&#160;

 <B>Date: </B>2021-01-11<BR>


<P>Consider the following example:</P>

<PRE>
  #include &lt;initializer_list&gt;
  struct A{
    operator short(){
      return 0;
    }
  };
  struct B{
    operator bool(){
      return 0;
    }
  };
  void fun(std::initializer_list&lt;int&gt;){}
  void fun(std::initializer_list&lt;bool&gt;){}
  int main(){
    fun({A{},B{}});
  }
</PRE>

<P>According to 12.2.4.2.6 [<A href="https://wg21.link/over.ics.list#6">over.ics.list</A>] paragraph 6,</P>

<BLOCKQUOTE>

Otherwise, if the parameter type is
<TT>std::initializer_list&lt;X&gt;</TT> and all the elements
of the initializer list can be implicitly converted
to <TT>X</TT>, the implicit conversion sequence is the worst
conversion necessary to convert an element of the list
to <TT>X</TT>, or if the initializer list has no elements,
the identity conversion. This conversion can be a
user-defined conversion even in the context of a call to an
initializer-list constructor.

</BLOCKQUOTE>

<P>In this example, all of the conversions from list elements
to the <TT>initializer_list</TT> template argument type are
user-defined conversions. According to 12.2.4.3 [<A href="https://wg21.link/over.ics.rank">over.ics.rank</A>]
bullet 3.3,</P>

<BLOCKQUOTE>

User-defined conversion sequence <TT>U1</TT> is a better
conversion sequence than another user-defined conversion
sequence <TT>U2</TT> if they contain the same user-defined
conversion function or constructor or they initialize the
same class in an aggregate initialization and in either case
the second standard conversion sequence of <TT>U1</TT> is
better than the second standard conversion sequence
of <TT>U2</TT>.

</BLOCKQUOTE>

<P>Since in both cases the two elements of the
initializer-list argument involve different user-defined
conversion functions, the two user-defined conversion
sequences for the elements cannot be distinguished, so the
determination of the &#8220;worst conversion&#8221; for the
two candidates does not consider the second standard
conversion sequence. This presumably makes it impossible to
distinguish the conversion sequences for the two candidates in
the function call, making the call ambiguous.</P>

<P>However, there is implementation divergence on
the handling of this example, with g++ reporting an
ambiguity and clang, MSVC, and EDG calling the <TT>int</TT>
overload, presumably on the basis
that <TT>short-&gt;int</TT> is a promotion
while <TT>short-&gt;bool</TT> is a conversion.</P>

<P><B>Notes from the August, 2021 teleconference:</B></P>

<P>CWG agreed with the reasoning expressed in the analysis,
that conversions involving different user-defined conversion
functions cannot be compared, and thus the call is
ambiguous. The use of the phrase &#8220;worst
conversion&#8221; is insufficiently clear, however, and
requires definition.</P>

<P><B>Proposed resolution, August, 2021:</B></P>

<P>Change 12.2.4.2.6 [<A href="https://wg21.link/over.ics.list">over.ics.list</A>] paragraphs 5 and 6 as
follows:</P>

<BLOCKQUOTE>

<P>Otherwise, if the parameter type is
<TT>std::initializer_list&lt;X&gt;</TT> and <INS>either the
initializer list is empty or</INS> all the elements of the
initializer list can be implicitly converted to <TT>X</TT>,
the implicit conversion sequence is the <DEL>worst conversion</DEL>
<INS><I>worst conversion</I></INS> necessary to convert an
element of the list to <TT>X</TT>, <DEL>or
if</DEL> <INS>defined as follows. If</INS> the initializer
list has no elements, the
<INS>worst conversion is the</INS> identity conversion.
<INS>Otherwise, the worst conversion is an implicit
conversion sequence for a list element that is not better
than any other implicit conversion sequence required by list
elements, compared as described in
12.2.4.3 [<A href="https://wg21.link/over.ics.rank">over.ics.rank</A>]. If more than one implicit
conversion sequence satisfies this criterion, then if they
are user-defined conversion sequences that do not all
contain the same user-defined conversion function or
constructor, the worst conversion sequence is the ambiguous
conversion sequence (12.2.4.2.1 [<A href="https://wg21.link/over.best.ics.general">over.best.ics.general</A>]);
otherwise, it is unspecified which of those conversion
sequences is chosen as worst.</INS> This conversion can be a
user-defined conversion even in the context of a call to an
initializer-list constructor.  [<I>Example 2</I>:</P>

<PRE>
  void f(std::initializer_list&lt;int&gt;);
  f( {} );        //<SPAN CLASS="cmnt"> OK: </SPAN>f(initializer_list&lt;int&gt;)<SPAN CLASS="cmnt"> identity conversion</SPAN>
  f( {1,2,3} );   //<SPAN CLASS="cmnt"> OK: </SPAN>f(initializer_list&lt;int&gt;)<SPAN CLASS="cmnt"> identity conversion</SPAN>
  f( {'a','b'} ); //<SPAN CLASS="cmnt"> OK: </SPAN>f(initializer_list&lt;int&gt;)<SPAN CLASS="cmnt"> integral promotion</SPAN>
  f( {1.0} );     //<SPAN CLASS="cmnt"> error: narrowing</SPAN>

  struct A {
    A(std::initializer_list&lt;double&gt;);            //<SPAN CLASS="cmnt"> #1</SPAN>
    A(std::initializer_list&lt;complex&lt;double&gt;&gt;);   //<SPAN CLASS="cmnt"> #2</SPAN>
    A(std::initializer_list&lt;std::string&gt;);       //<SPAN CLASS="cmnt"> #3</SPAN>
  };
  A a{ 1.0,2.0 };        //<SPAN CLASS="cmnt"> OK, uses #1</SPAN>

  void g(A);
  g({ "foo", "bar" });   //<SPAN CLASS="cmnt"> OK, uses #3</SPAN>

  typedef int IA[3];
  void h(const IA&amp;);
  h({ 1, 2, 3 });        //<SPAN CLASS="cmnt"> OK: identity conversion</SPAN>

<INS>  void x(std::initializer_list&lt;int&gt;);
  void x(std::initializer_list&lt;bool&gt;);
  struct S1 { operator short(); };
  struct S2 { operator bool(); };
  void y() {
    x({S1{}, S2{}});   //<SPAN CLASS="cmnt"> error: ambiguous. The ICSes for each list element are indistinguishable because</SPAN>
                       //<SPAN CLASS="cmnt"> they do not contain the same conversion function, so the worst conversion is</SPAN>
                       //<SPAN CLASS="cmnt"> the ambiguous conversion sequence.</SPAN>
  }</INS>
</PRE>

<P>&#8212;<I>end example</I>]</P>

<P>Otherwise, if the parameter type is &#8220;array of <TT>N
X</TT> &#8221; or &#8220;array of unknown bound
of <TT>X</TT>&#8221;, if there exists an implicit conversion
sequence from each element of the initializer list (and from
<TT>{}</TT> in the former case if <TT>N</TT> exceeds the
number of elements in the initializer list) to <TT>X</TT>,
the implicit conversion sequence is the worst <DEL>such
implicit conversion sequence</DEL> <INS>conversion necessary
to convert an element of the list (including, if there are
too few list elements, <TT>{}</TT>) to
<TT>X</TT>, determined as described above for a
<TT>std::initializer_list&lt;X&gt;</TT> with a non-empty
initializer list</INS>.</P>

</BLOCKQUOTE>

<P><B>CWG 2023-06-13</B></P>

<P>An ambiguous conversion for the function selected by overload
resolution is ill-formed per 12.2.4.2.1 [<A href="https://wg21.link/over.best.ics.general">over.best.ics.general</A>].  Instead
of attempting to define "worst conversion" (possibly with focusing on
the second standard conversion sequence in user-defined conversions),
it might be more consistent overall to use the rules for a succession
of function arguments/parameters when comparing list-initializations.</P>

<BR><BR>
</BODY>
</HTML>
