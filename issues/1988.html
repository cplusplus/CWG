<HTML>
<HEAD>
<meta http-equiv="Content-Type" content="text/html; charset=us-ascii">
<TITLE>
    CWG Issue 1988</TITLE>
<STYLE TYPE="text/css">
  INS { text-decoration:none; font-weight:bold; background-color:#A0FFA0 }
  .INS { text-decoration:none; background-color:#D0FFD0 }
  DEL { text-decoration:line-through; background-color:#FFA0A0 }
  .DEL { text-decoration:line-through; background-color: #FFD0D0 }
  SPAN.cmnt { font-family:Times; font-style:italic }
</STYLE>
</HEAD>
<BODY>
<P><EM>This is an unofficial snapshot of the ISO/IEC JTC1 SC22 WG21
  Core Issues List revision 116a.
  See http://www.open-std.org/jtc1/sc22/wg21/ for the official
  list.</EM></P>
<P>2024-12-19</P>
<HR>
<A NAME="1988"></A><H4>1988.
  
Ambiguity between dependent and non-dependent bases in implicit member access
</H4>
<B>Section: </B>13.8.3.2&#160; [<A href="https://wg21.link/temp.dep.type">temp.dep.type</A>]
 &#160;&#160;&#160;

 <B>Status: </B>CD4
 &#160;&#160;&#160;

 <B>Submitter: </B>Richard Smith
 &#160;&#160;&#160;

 <B>Date: </B>2014-08-22<BR>


<P>[Moved to DR at the May, 2015 meeting.]</P>



<P>According to 13.8.3.2 [<A href="https://wg21.link/temp.dep.type#7">temp.dep.type</A>] paragraph 7,</P>

<BLOCKQUOTE>

If, for a given set of template arguments, a specialization of a template
is instantiated that refers to a member of the current instantiation with
a <I>qualified-id</I> or class member access expression, the name in
the <I>qualified-id</I> or class member access expression is looked up in
the template instantiation context. If the result of this lookup differs
from the result of name lookup in the template definition context, name
lookup is ambiguous.  [<I>Note:</I> the result of name lookup differs only
when the member of the current instantiation was found in a non-dependent
base class of the current instantiation and a member with the same name is
also introduced by the substitution for a dependent base class of the
current instantiation. &#8212;<I>end note</I>]

</BLOCKQUOTE>

<P>It is not clear whether this applies to an example like,</P>

<PRE>
   struct A { int n; };
   struct B { int n; };
   template&lt;typename T&gt; struct C : T, B {
     int f() { return n; }
   };
   int k = C&lt;A&gt;().f();
</PRE>

<P>since the reference to <TT>n</TT> is transformed into a class
member access expression, per 11.4.3 [<A href="https://wg21.link/class.mfct.non.static#3">class.mfct.non.static</A>] paragraph 3.</P>

<P><B>Notes from the November, 2014 meeting:</B></P>

<P>The transformation to a member access expression or
<I>qualified-id</I> should be performed only in the instantiated
function, not when processing the template definition.</P>

<P><B>Proposed resolution (April, 2015):</B></P>

<OL>
<LI><P>Change 11.4.3 [<A href="https://wg21.link/class.mfct.non.static#3">class.mfct.non.static</A>] paragraph 3 as follows:</P></LI>

<BLOCKQUOTE>

When an <I>id-expression</I> (7.5 [<A href="https://wg21.link/expr.prim">expr.prim</A>]) that is
not part of a class member access syntax
(7.6.1.5 [<A href="https://wg21.link/expr.ref">expr.ref</A>]) and not used to form a pointer to
member (7.6.2.2 [<A href="https://wg21.link/expr.unary.op">expr.unary.op</A>]) is used in a member of class
<TT>X</TT> in a context where <TT>this</TT> can be used
(_N4567_.5.1.1 [<A href="https://wg21.link/expr.prim.general">expr.prim.general</A>]), if name lookup
(6.5 [<A href="https://wg21.link/basic.lookup">basic.lookup</A>]) resolves the name in
the <I>id-expression</I> to a non-static non-type member of some
class <TT>C</TT>, and if either the <I>id-expression</I> is
potentially evaluated or <TT>C</TT> is <TT>X</TT> or a base class
of <TT>X</TT>, the <I>id-expression</I> is transformed into a
class member access expression (7.6.1.5 [<A href="https://wg21.link/expr.ref">expr.ref</A>])
using <TT>(*this)</TT> (_N4868_.11.4.3.2 [<A href="https://wg21.link/class.this">class.this</A>]) as
the <I>postfix-expression</I> to the left of the <TT>.</TT>
operator. [<I>Note:</I> If <TT>C</TT> is not <TT>X</TT> or a base
class of <TT>X</TT>, the class member access expression is
ill-formed. &#8212;<I>end note</I>] Similarly during name lookup,
when an <I>unqualified-id</I> (7.5 [<A href="https://wg21.link/expr.prim">expr.prim</A>]) used in
the definition of a member function for class <TT>X</TT> resolves
to a <TT>static</TT> member, an enumerator or a nested type of
class <TT>X</TT> or of a base class of <TT>X</TT>,
the <I>unqualified-id</I> is transformed into
a <I>qualified-id</I> (7.5 [<A href="https://wg21.link/expr.prim">expr.prim</A>]) in which
the <I>nested-name-specifier</I> names the class of the member
function. <INS>These transformations do not apply in the template
definition context (13.8.3.2 [<A href="https://wg21.link/temp.dep.type">temp.dep.type</A>]).</INS>
[<I>Example:</I>...

</BLOCKQUOTE>

<LI><P>Change the example in 13.8.3.2 [<A href="https://wg21.link/temp.dep.type">temp.dep.type</A>] paragraph
7, as modified by the resolution of <A HREF="1309.html">issue 1309</A>,
as follows:</P></LI>

<BLOCKQUOTE>

<PRE>
  struct A {
    int m;
  };

  struct B {
    int m;
  };

  template&lt;typename T&gt;
  struct C : A, T {
    int f() { return this-&gt;m; }//<SPAN CLASS="cmnt"> finds </SPAN>A::m<SPAN CLASS="cmnt"> in the template definition context</SPAN>
  <INS>  int g() { return m; }      //<SPAN CLASS="cmnt"> finds </SPAN>A::m<SPAN CLASS="cmnt"> in the template definition context</SPAN></INS>
  };

  template int C&lt;B&gt;::f();      //<SPAN CLASS="cmnt"> error: finds both </SPAN>A::m<SPAN CLASS="cmnt"> and </SPAN>B::m
<INS>  template int C&lt;B&gt;::g();      //<SPAN CLASS="cmnt"> OK: transformation to class member access syntax</SPAN>
                               //<SPAN CLASS="cmnt"> does not occur in the template definition context; see 11.4.3 [<A href="https://wg21.link/class.mfct.non.static">class.mfct.non.static</A>]</SPAN></INS>
</PRE>

</BLOCKQUOTE>

</OL>

<BR><BR>
</BODY>
</HTML>
