<HTML>
<HEAD>
<meta http-equiv="Content-Type" content="text/html; charset=us-ascii">
<TITLE>
    CWG Issue 426</TITLE>
<STYLE TYPE="text/css">
  INS { text-decoration:none; font-weight:bold; background-color:#A0FFA0 }
  .INS { text-decoration:none; background-color:#D0FFD0 }
  DEL { text-decoration:line-through; background-color:#FFA0A0 }
  .DEL { text-decoration:line-through; background-color: #FFD0D0 }
  SPAN.cmnt { font-family:Times; font-style:italic }
</STYLE>
</HEAD>
<BODY>
<P><EM>This is an unofficial snapshot of the ISO/IEC JTC1 SC22 WG21
  Core Issues List revision 116b.
  See http://www.open-std.org/jtc1/sc22/wg21/ for the official
  list.</EM></P>
<P>2025-03-05</P>
<HR>
<A NAME="426"></A><H4>426.
  
Identically-named variables, one internally and one externally linked, allowed?
</H4>
<B>Section: </B>6.6&#160; [<A href="https://wg21.link/basic.link">basic.link</A>]
 &#160;&#160;&#160;

 <B>Status: </B>C++17
 &#160;&#160;&#160;

 <B>Submitter: </B>Steve Adamczyk
 &#160;&#160;&#160;

 <B>Date: </B>2 July 2003<BR>


<P>[Adopted at the February/March, 2017 meeting.]</P>

<P>An example in
6.6 [<A href="https://wg21.link/basic.link#6">basic.link</A>] paragraph 6 creates two file-scope variables
with the same name,
one with internal linkage and one with external.</P>
<PRE>
  static void f();
  static int i = 0;                       //1
  void g() {
          extern void f();                // internal linkage
          int i;                          //2: i has no linkage
          {
                  extern void f();        // internal linkage
                  extern int i;           //3: external linkage
          }
  }
</PRE>
<P>Is this really what we want?
C99 has 6.2.2.7/7,
which gives undefined behavior for having an identifier appear with
internal and external linkage in the same translation unit.  C++
doesn't seem to have an equivalent.</P>

<P><B>Notes from October 2003 meeting:</B></P>

<P>We agree that this is an error.  We propose to leave the example
but change the comment to indicate that line //3 has undefined
behavior, and elsewhere add a normative rule giving such a
case undefined behavior.</P>

<P><B>Proposed resolution (October, 2005) [SUPERSEDED]:</B></P>

<P>Change 6.6 [<A href="https://wg21.link/basic.link#6">basic.link</A>] paragraph 6 as indicated:</P>

<BLOCKQUOTE>

<P>...Otherwise, if no matching entity is found, the block scope entity
receives external linkage.  <INS>If, within a translation unit, the same
entity is declared with both internal and external linkage, the
behavior is undefined.</INS>
</P>

<P>[<I>Example:</I>
</P>

<PRE>
    static void f();
    static int i = 0;            //<SPAN CLASS="cmnt"> 1</SPAN>
    void g () {
        extern void f ();        //<SPAN CLASS="cmnt"> internal linkage</SPAN>
        int i;                   //<SPAN CLASS="cmnt"> 2: </SPAN>i<SPAN CLASS="cmnt"> has no linkage</SPAN>
        {
            extern void f ();    //<SPAN CLASS="cmnt"> internal linkage</SPAN>
            extern int i;        //<SPAN CLASS="cmnt"> 3: external linkage</SPAN>
        }
    }
</PRE>

<P>
<DEL>There are three objects named <TT>i</TT> in this program.  The
object with internal linkage introduced by the declaration in global
scope (line <TT>//1</TT> ), the object with automatic storage duration
and no linkage introduced by the declaration on line <TT>//2</TT>, and
the object with static storage duration and external linkage
introduced by the declaration on line <TT>//3</TT>.</DEL> <INS>Without the
declaration at line <TT>//2</TT>, the declaration at line <TT>//3</TT>
would link with the declaration at line <TT>//1</TT>.  But because the
declaration with internal linkage is hidden, <TT>//3</TT> is given
external linkage, resulting in a linkage conflict.</INS> &#8212;<I>end
example</I>]</P>

</BLOCKQUOTE>

<P><B>Notes from the April 2006 meeting:</B></P>

<P>According to 6.6 [<A href="https://wg21.link/basic.link#9">basic.link</A>] paragraph 9, the two
variables with linkage in the proposed example are not &#8220;the
same entity&#8221; because they do not have the same linkage.  Some other
formulation will be needed to describe the relationship between those
two variables.</P>

<P><B>Notes from the October 2006 meeting:</B></P>

<P>The CWG decided that it would be better to make a program with this
kind of linkage mismatch ill-formed instead of having undefined
behavior.</P>

<P><B>Proposed resolution (November, 2016):</B></P>

<P>Change 6.6 [<A href="https://wg21.link/basic.link#6">basic.link</A>] paragraph 6 as follows:</P>

<BLOCKQUOTE>

<P>...Otherwise, if no matching entity is found, the block scope entity
receives external linkage. <INS>If, within a translation unit, the
same entity is declared with both internal and external linkage, the
program is ill-formed.</INS> [<I>Example:</I>
</P>

<PRE>
  static void f();
  static int i = 0;     //<SPAN CLASS="cmnt"> #1</SPAN>
  void g() {
    extern void f();    //<SPAN CLASS="cmnt"> internal linkage</SPAN>
    int i;              //<SPAN CLASS="cmnt"> #2<INS>:</INS> </SPAN>i<SPAN CLASS="cmnt"> has no linkage</SPAN>
    {
      extern void f();  //<SPAN CLASS="cmnt"> internal linkage</SPAN>
      extern int i;     //<SPAN CLASS="cmnt"> #3 external linkage<INS>, ill-formed</INS></SPAN>
    }
  }
</PRE>

<P>
<DEL>There are three objects named <TT>i</TT> in this program. The
object with internal linkage introduced by the declaration in global scope
(line #1 ), the object with automatic storage duration and no linkage
introduced by the declaration on line #2, and the object with static
storage duration and external linkage introduced by the declaration on line
#3.</DEL> <INS> Without the declaration at line #2, the declaration at line
#3 would link with the declaration at line #1. Because the declaration with
internal linkage is hidden, however, #3 is given external linkage, making
the program ill-formed.</INS> &#8212;<I>end example</I>]</P>

</BLOCKQUOTE>

<BR><BR>
</BODY>
</HTML>
