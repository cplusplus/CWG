<HTML>
<HEAD>
<meta http-equiv="Content-Type" content="text/html; charset=us-ascii">
<TITLE>
    CWG Issue 531</TITLE>
<STYLE TYPE="text/css">
  INS { text-decoration:none; font-weight:bold; background-color:#A0FFA0 }
  .INS { text-decoration:none; background-color:#D0FFD0 }
  DEL { text-decoration:line-through; background-color:#FFA0A0 }
  .DEL { text-decoration:line-through; background-color: #FFD0D0 }
  SPAN.cmnt { font-family:Times; font-style:italic }
</STYLE>
</HEAD>
<BODY>
<P><EM>This is an unofficial snapshot of the ISO/IEC JTC1 SC22 WG21
  Core Issues List revision 116.
  See http://www.open-std.org/jtc1/sc22/wg21/ for the official
  list.</EM></P>
<P>2024-12-19</P>
<HR>
<A NAME="531"></A><H4>531.
  
Defining members of explicit specializations
</H4>
<B>Section: </B>13.9.4&#160; [<A href="https://wg21.link/temp.expl.spec">temp.expl.spec</A>]
 &#160;&#160;&#160;

 <B>Status: </B>C++11
 &#160;&#160;&#160;

 <B>Submitter: </B>Mike Miller
 &#160;&#160;&#160;

 <B>Date: </B>1 October 2005<BR>


<P>[Voted into the WP at the March, 2011 meeting as part of paper N3262.]</P>

<P>The Standard does not fully describe the syntax to be used when a
member of an explicitly-specialized member class or member class
template is defined in namespace scope.  13.9.4 [<A href="https://wg21.link/temp.expl.spec#4">temp.expl.spec</A>] paragraph 4
says that the &#8220;explicit specialization syntax&#8221;
(presumably referring to &#8220;<TT>template&lt;&gt;</TT>&#8221;) is
not used in defining a member of an explicit specialization when a
class template is explicitly specialized as a class.  However, nothing
is said anywhere about how to define a member of a specialization
when:</P>

<OL>
<LI><P>the entity being specialized is a class (member of a
template class) rather than a class template.</P></LI>

<LI><P>the result of the specialization is a class template rather
than a class (cf 13.9.4 [<A href="https://wg21.link/temp.expl.spec#18">temp.expl.spec</A>] paragraph 18, which
describes this case as a &#8220;member template that...
remain[s] unspecialized&#8221;).</P></LI>
</OL>

<P>(See paper J16/05-0148 = WG21 N1888 for further details, including
a survey of existing implementation practice.)</P>

<P><B>Notes from the October, 2005 meeting:</B></P>

<P>The CWG felt that the best approach, balancing consistency with
implementation issues and existing practice, would be to require that
<TT>template&lt;&gt;</TT> be used when defining members of all
explicit specializations, including those currently covered by
13.9.4 [<A href="https://wg21.link/temp.expl.spec#4">temp.expl.spec</A>] paragraph 4.</P>

<P><B>Proposed resolution (February, 2010) [SUPERSEDED]:</B></P>

<P>Change 13.9.4 [<A href="https://wg21.link/temp.expl.spec#5">temp.expl.spec</A>] paragraph 5 as follows:</P>

<BLOCKQUOTE>

<P>...The definition of an explicitly specialized class is
unrelated to the definition of a generated specialization. That
is, its members need not have the same names, types, etc. as the
members of a generated specialization. Definitions of members of
an explicitly specialized class are defined <DEL>in the same
manner as members of normal classes, and not using the syntax for
explicit specialization</DEL> <INS>using the same
<TT>template&lt;&gt;</TT> prefix(es) as the explicitly
specialized class</INS>. [<I>Example:</I>
</P>

<PRE>
    template&lt;class T&gt; struct A {
      void f(T) { /* ... */ }
<INS>      struct B { /* ... */ };
      template&lt;class U&gt; struct C { /* ... */ };</INS>
    };
    template&lt;&gt; struct A&lt;int&gt; {
      void f(int);
<INS>      struct B;
      template&lt;class U&gt; struct C;</INS>
    };
    void h() {
      A&lt;int&gt; a;
      a.f(16); // A&lt;int&gt;::f <SPAN CLASS="cmnt">must be defined somewhere</SPAN>
    }
<DEL>    //<SPAN CLASS="cmnt"> explicit specialization syntax not used for a member of</SPAN>
    //<SPAN CLASS="cmnt"> explicitly specialized class template specialization</SPAN></DEL>
<INS>    //<SPAN CLASS="cmnt"> members of explicitly specialized classes are defined using</SPAN>
    //<SPAN CLASS="cmnt">the same syntax as the explicitly specialized class:</SPAN></INS>
    <INS>template&lt;&gt; </INS>void A&lt;int&gt;::f(int) { /* ... */ }
<INS>    template&lt;&gt; struct A&lt;int&gt;::B { /* ... */ };
    template&lt;&gt; template&lt;class T&gt; struct A&lt;int&gt;::C { /* ... */ };</INS>
</PRE>

<P>&#8212;<I>end example</I>]</P>

</BLOCKQUOTE>

<P><B>Note (June, 2010):</B></P>

<P>Because the survey of implementations on which the CWG relied in
reaching this resolution is quite old, a new survey of current
practice is needed.</P>

<BR><BR>
</BODY>
</HTML>
