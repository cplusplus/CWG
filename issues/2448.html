<HTML>
<HEAD>
<meta http-equiv="Content-Type" content="text/html; charset=us-ascii">
<TITLE>
    CWG Issue 2448</TITLE>
<STYLE TYPE="text/css">
  INS { text-decoration:none; font-weight:bold; background-color:#A0FFA0 }
  .INS { text-decoration:none; background-color:#D0FFD0 }
  DEL { text-decoration:line-through; background-color:#FFA0A0 }
  .DEL { text-decoration:line-through; background-color: #FFD0D0 }
  SPAN.cmnt { font-family:Times; font-style:italic }
</STYLE>
</HEAD>
<BODY>
<P><EM>This is an unofficial snapshot of the ISO/IEC JTC1 SC22 WG21
  Core Issues List revision 116b.
  See http://www.open-std.org/jtc1/sc22/wg21/ for the official
  list.</EM></P>
<P>2025-03-05</P>
<HR>
<A NAME="2448"></A><H4>2448.
  
Cv-qualification of arithmetic types and deprecation of volatile
</H4>
<B>Section: </B>6.8.2&#160; [<A href="https://wg21.link/basic.fundamental">basic.fundamental</A>]
 &#160;&#160;&#160;

 <B>Status: </B>CD6
 &#160;&#160;&#160;

 <B>Submitter: </B>Alisdair Meredith
 &#160;&#160;&#160;

 <B>Date: </B>2020-03-23<BR>


<P>[Accepted as a DR at the June, 2021 meeting.]</P>

<P>According to the definitions in 6.8.2 [<A href="https://wg21.link/basic.fundamental">basic.fundamental</A>],
the arithmetic types include only the non-cv-qualified versions.
In the taxonomy of fundamental types, the first mention of
&#8220;cv-qualified versions of these types&#8221; is for
scalar types (6.8 [<A href="https://wg21.link/basic.types#9">basic.types</A>] paragraph 9). However,
7.6.1.6 [<A href="https://wg21.link/expr.post.incr#1">expr.post.incr</A>] paragraph 1 and
7.6.2.3 [<A href="https://wg21.link/expr.pre.incr#1">expr.pre.incr</A>] paragraph 1 both say:</P>

<BLOCKQUOTE>

The type of the operand shall be an arithmetic type other
than <I>cv</I> <TT>bool</TT>, or...

</BLOCKQUOTE>

<P>which is a contradiction, since cv-qualified <TT>bool</TT>
is not an arithmetic type. Similarly, 7.6.19 [<A href="https://wg21.link/expr.ass#6">expr.ass</A>] paragraph 6
requires an arithmetic type for <TT>+=</TT>
and <TT>-=</TT>. D.4 [<A href="https://wg21.link/depr.volatile.type">depr.volatile.type</A>] deprecates
the increment and decrement operators when applied to
volatile-qualified arithmetic types, but the wording already
made those ill-formed (since the normative wording requires
an arithmetic type and not a possibly cv-qualified version
thereof).</P>

<P>A related question is whether 12.5 [<A href="https://wg21.link/over.built">over.built</A>],
which explicitly allows for cv-qualified arithmetic types,
should also note the deprecation.</P>

<P>See also <A HREF="2185.html">issue 2185</A>.</P>

<P><B>Notes from the July, 2020 teleconference:</B></P>

<P>CWG felt that no changes should be made to
12.5 [<A href="https://wg21.link/over.built">over.built</A>].</P>

<P><B>Proposed resolution (April, 2021):</B></P>

<OL>
<LI><P>Change 6.8.2 [<A href="https://wg21.link/basic.fundamental">basic.fundamental</A>] paragraphs 11 and 12 as follows,
splitting paragraph 12 as indicated:</P></LI>

<BLOCKQUOTE>

<P>Types <TT>bool</TT>, <TT>char</TT>, <TT>wchar_t</TT>,
<TT>char8_t</TT>, <TT>char16_t</TT>, <TT>char32_t</TT>, and
the signed and unsigned integer types<INS>, and cv-qualified
versions (6.8.5 [<A href="https://wg21.link/basic.type.qualifier">basic.type.qualifier</A>]) thereof,</INS> are
collectively <DEL>called</DEL> <INS>termed</INS>
<I>integral types</I>. A synonym for integral type
is <I>integer type</I>.  [<I>Note 8:</I> Enumerations
(9.7.1 [<A href="https://wg21.link/dcl.enum">dcl.enum</A>]) are not integral; however,
unscoped enumerations can be promoted to integral types as
specified in 7.3.7 [<A href="https://wg21.link/conv.prom">conv.prom</A>]. &#8212;<I>end
note</I>]</P>

<P>
<DEL>There are <I>three floating-point types</I>:</DEL>
<INS>The three distinct types</INS> <TT>float</TT>,
<TT>double</TT>, and <TT>long double</TT> <INS>can represent
floating-point numbers</INS>. The type <TT>double</TT>
provides at least as much precision as <TT>float</TT>, and the type
<TT>long double</TT> provides at least as much precision as
<TT>double</TT>. The set of values of the
type <TT>float</TT> is a subset of the set of values of the
type <TT>double</TT>; the set of values of the
type <TT>double</TT> is a subset of the set of values of the
type <TT>long double</TT>. <INS>The types <TT>float</TT>,
<TT>double</TT>, and <TT>long double</TT>, and cv-qualified
versions (6.8.5 [<A href="https://wg21.link/basic.type.qualifier">basic.type.qualifier</A>]) thereof, are
collectively termed <I>floating-point types</I>.</INS> The
value representation of floating-point types is
implementation-defined.  <I>[Note 9:</I> This document
imposes no requirements on the accuracy of floating-point
operations; see also
17.3 [<A href="https://wg21.link/support.limits">support.limits</A>]. &#8212;<I>end note</I>]</P>

<P>Integral and floating-point types are
collectively <DEL>called</DEL> <INS>termed</INS>
<I>arithmetic types</I>. Specializations of the standard
library template <TT>std::numeric_limits</TT>
(17.3 [<A href="https://wg21.link/support.limits">support.limits</A>]) shall specify the maximum and
minimum values of each arithmetic type for an
implementation.</P>

</BLOCKQUOTE>

<LI><P>Change 6.8.5 [<A href="https://wg21.link/basic.type.qualifier#1">basic.type.qualifier</A>] paragraph 1 as follows,
splitting the paragraph as indicated:</P></LI>

<BLOCKQUOTE>

<P>
<DEL>A type mentioned in 6.8.2 [<A href="https://wg21.link/basic.fundamental">basic.fundamental</A>] and
6.8.4 [<A href="https://wg21.link/basic.compound">basic.compound</A>] is a <I>cv-unqualified</I>
type.</DEL> Each type <DEL>which is a cv-unqualified object type
or is <TT>void</TT> (6.8 [<A href="https://wg21.link/basic.types">basic.types</A>]) has three
corresponding cv-qualified versions of its type</DEL>
<INS>other than a function or reference type is part of a
group of four distinct, but related,
types</INS>: <INS>a <I>cv-unqualified</I> version,</INS>
a <I>const-qualified</I> version,
a <I>volatile-qualified</I> version, and
a <I>const-volatile-qualified</I> version.
<DEL>The type of an object (6.7.2 [<A href="https://wg21.link/intro.object">intro.object</A>])
includes the <I>cv-qualifier</I>s specified in
the <I>decl-specifier-seq</I> (9.2 [<A href="https://wg21.link/dcl.spec">dcl.spec</A>]),
<I>declarator</I> (9.3 [<A href="https://wg21.link/dcl.decl">dcl.decl</A>]), <I>type-id</I>
(9.3.2 [<A href="https://wg21.link/dcl.name">dcl.name</A>]), or <I>new-type-id</I>
(7.6.2.8 [<A href="https://wg21.link/expr.new">expr.new</A>]) when the object is
created.</DEL> <INS>The types in each such group shall have
the same representation and alignment requirements
(6.7.3 [<A href="https://wg21.link/basic.align">basic.align</A>]).  [<I>Footnote:</I> The same
representation and alignment requirements are meant to imply
interchangeability as arguments to functions, return values
from functions, and non-static data members of
unions. &#8212;<I>end footnote</I>] A function or reference
type is always cv-unqualified.</INS>
</P>

<UL>
<LI><P>A <I>const object</I> is an object of
type <TT>const T</TT> or a non-mutable subobject of a const
object.</P></LI>

<LI><P>A <I>volatile object</I> is an object of
type <TT>volatile T</TT> or a subobject of a volatile
object.</P></LI>

<LI><P>A <I>const volatile object</I> is an object of
type <TT>const volatile T</TT>, a non-mutable subobject of a
const volatile object, a const subobject of a volatile
object, or a non-mutable volatile subobject of a const
object.</P></LI>

</UL>

<P>
<DEL>The cv-qualified or cv-unqualified versions of a
type are distinct types; however, they shall have the same
representation and alignment requirements
(6.7.3 [<A href="https://wg21.link/basic.align">basic.align</A>]).<SUP>40</SUP></DEL> <INS>[<I>Note:</I>
The type of an object (6.7.2 [<A href="https://wg21.link/intro.object">intro.object</A>]) includes
the <I>cv-qualifier</I>s specified in the
<I>decl-specifier-seq</I> (9.2 [<A href="https://wg21.link/dcl.spec">dcl.spec</A>]),
<I>declarator</I> (9.3 [<A href="https://wg21.link/dcl.decl">dcl.decl</A>]), <I>type-id</I>
(9.3.2 [<A href="https://wg21.link/dcl.name">dcl.name</A>]), or <I>new-type-id</I>
(7.6.2.8 [<A href="https://wg21.link/expr.new">expr.new</A>]) when the object is created.
&#8212;<I>end note</I>]</INS>
</P>

</BLOCKQUOTE>

<LI><P>Change 12.5 [<A href="https://wg21.link/over.built">over.built</A>] paragraphs 2-10 as follows:</P></LI>

<BLOCKQUOTE>

<P>In this subclause, the term <I>promoted integral type</I>
is used to refer to those <INS>cv-unqualified</INS> integral
types which are preserved by integral promotion
(7.3.7 [<A href="https://wg21.link/conv.prom">conv.prom</A>]) (including e.g. <TT>int</TT>
and <TT>long</TT> but excluding e.g. <TT>char</TT>
). [<I>Note 2:</I> In all cases where a promoted integral
type is required, an operand of unscoped enumeration type
will be acceptable by way of the integral
promotions. &#8212;<I>end note</I>]</P>

<P>In the remainder of this subclause, <I>vq</I>
represents either <TT>volatile</TT> or no cv-qualifier.</P>

<P>For every pair (<I>T, vq</I>), where <I>T</I> is <DEL>an</DEL>
<INS>a cv-unqualified</INS> arithmetic type other
than <TT>bool</TT> <INS>or a cv-unqualified pointer to
(possibly cv-qualified) object type</INS>, there exist
candidate operator functions of the form</P>

<UL>
<I>vq T</I><TT>&amp; operator++(</TT><I>vq T</I><TT>&amp;);</TT><BR>
<I>T</I> <TT>operator++(</TT><I>vq T</I><TT>&amp;, int);</TT>
</UL>

<P><DEL>For every pair (<I>T, vq</I>), where <I>T</I> is an
arithmetic type other than <TT>bool</TT>, there exist
candidate operator functions of the form</DEL></P>

<UL>
<I>vq T</I><TT>&amp; operator--(</TT><I>vq T</I><TT>&amp;);</TT><BR>
<I>T</I> <TT>operator--(</TT><I>vq T</I><TT>&amp;, int);</TT>
</UL>

<P><DEL>For every pair (<I>T, vq</I>), where <I>T</I> is a
cv-qualified or cv-unqualified object type, there exist
candidate operator functions of the form</DEL></P>

<UL>
<DEL><I>T*vq</I><TT>&amp; operator++(</TT><I>T*vq</I><TT>&amp;);</TT><BR>
<I>T*vq</I><TT>&amp; operator--(</TT><I>T*vq</I><TT>&amp;);</TT><BR>
<I>T*</I><TT>&#160;&#160;&#160;&#160;operator++(</TT><I>T*vq</I><TT>&amp;, int);</TT><BR>
<I>T*</I><TT>&#160;&#160;&#160;&#160;operator--(</TT><I>T*vq</I><TT>&amp;, int);</TT></DEL>
</UL>

<P>For every <DEL>cv-qualified or cv-unqualified</DEL>
<INS>(possibly cv-qualified)</INS> object type <I>T</I>
<INS>and for every function type <I>T</I> that has neither
cv-qualifiers nor a <I>ref-qualifier</I></INS>,
there exist candidate operator functions of the form</P>

<UL>
<I>T</I><TT>&amp; operator*(</TT><I>T</I><TT>*);</TT>
</UL>

<P><DEL>For every function type <I>T</I> that does not have
cv-qualifiers or a ref-qualifier, there exist candidate
operator functions of the form</DEL></P>

<UL>
<DEL><I>T</I><TT>&amp; operator*(</TT><I>T</I><TT>*);</TT></DEL>
</UL>

<P>For every type <I>T</I> there exist candidate operator
functions of the form</P>

<UL>
<I>T</I><TT>* operator+(</TT><I>T</I><TT>*);</TT>
</UL>

<P>For every <INS>cv-unqualified</INS> floating-point or
promoted integral type <I>T</I>, there exist candidate
operator functions of the form</P>

<UL>
<I>T</I><TT> operator+(</TT><I>T</I><TT>);</TT><BR>
<I>T</I><TT>l operator-(</TT><I>T</I><TT>);</TT>
</UL>

</BLOCKQUOTE>

</OL>

<P><I>[Drafting note: Clause 21 [<A href="https://wg21.link/meta">meta</A>] regarding
type traits appropriately handles cv-qualified and
cv-unqualified types and does not require revision.]</I></P>

<BR><BR>
</BODY>
</HTML>
