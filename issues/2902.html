<HTML>
<HEAD>
<meta http-equiv="Content-Type" content="text/html; charset=us-ascii">
<TITLE>
    CWG Issue 2902</TITLE>
<STYLE TYPE="text/css">
  INS { text-decoration:none; font-weight:bold; background-color:#A0FFA0 }
  .INS { text-decoration:none; background-color:#D0FFD0 }
  DEL { text-decoration:line-through; background-color:#FFA0A0 }
  .DEL { text-decoration:line-through; background-color: #FFD0D0 }
  SPAN.cmnt { font-family:Times; font-style:italic }
</STYLE>
</HEAD>
<BODY>
<P><EM>This is an unofficial snapshot of the ISO/IEC JTC1 SC22 WG21
  Core Issues List revision 116.
  See http://www.open-std.org/jtc1/sc22/wg21/ for the official
  list.</EM></P>
<P>2024-12-19</P>
<HR>
<A NAME="2902"></A><H4>2902.
  
Implicit <TT>this</TT> transformation outside of permitted contexts
</H4>
<B>Section: </B>7.5.5.1&#160; [<A href="https://wg21.link/expr.prim.id.general">expr.prim.id.general</A>]
 &#160;&#160;&#160;

 <B>Status: </B>review
 &#160;&#160;&#160;

 <B>Submitter: </B>Vincent X
 &#160;&#160;&#160;

 <B>Date: </B>2024-06-14<BR>


<P>(From submission
<A HREF="https://github.com/cplusplus/CWG/issues/553">#553</A>.)</P>

<P>Subclause 7.5.5.1 [<A href="https://wg21.link/expr.prim.id.general#2">expr.prim.id.general</A>] paragraph 2 specifies:</P>

<BLOCKQUOTE>

If an <I>id-expression</I> E denotes a non-static non-type member of
some class C at a point where the current class
(7.5.3 [<A href="https://wg21.link/expr.prim.this">expr.prim.this</A>]) is X and
<UL>
<LI>E is potentially
evaluated or C is X or a base class of X, and</LI>
<LI>E is not
the <I>id-expression</I> of a class member access expression
(7.6.1.5 [<A href="https://wg21.link/expr.ref">expr.ref</A>]), and</LI>
<LI>if E is a <I>qualified-id</I>, E is not the un-parenthesized
operand of the unary &amp; operator
(7.6.2.2 [<A href="https://wg21.link/expr.unary.op">expr.unary.op</A>]),</LI>
</UL>
the <I>id-expression</I> is transformed into a class member access
expression using (*this) as the object expression.

</BLOCKQUOTE>

<P>This rule transforms the following valid code (according to the
example in 7.5.3 [<A href="https://wg21.link/expr.prim.this#5">expr.prim.this</A>] paragraph 5) into invalid code:</P>

<PRE>
  struct A {
   int x;
   int a[sizeof(x)];
   decltype(x) f();
  };
</PRE>

<P>This is a regression introduced by 
<A HREF="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1787r6.html">P1787R6</A>
(Declarations and where to find them).</P>

<P><B>Proposed resolution (reviewed by CWG 2024-06-14) [SUPERSEDED]:</B></P>

<P>Change in 7.5.5.1 [<A href="https://wg21.link/expr.prim.id.general#2">expr.prim.id.general</A>] paragraph 2 as follows:</P>

<BLOCKQUOTE>

If an <I>id-expression</I> E denotes a non-static non-type member of
some class C at a point where the current class
(7.5.3 [<A href="https://wg21.link/expr.prim.this">expr.prim.this</A>]) is X and
<UL>
<LI class="ins">the point is in a context where
7.5.3 [<A href="https://wg21.link/expr.prim.this">expr.prim.this</A>] specifies a type for <TT>this</TT>,
and</LI>
<LI>E is potentially evaluated or C is X or a base class of X,
and</LI>
<LI>E is not the <I>id-expression</I> of a class member access
expression (7.6.1.5 [<A href="https://wg21.link/expr.ref">expr.ref</A>]), and</LI>
<LI>if E is a <I>qualified-id</I>, E is not the un-parenthesized
operand of the unary &amp; operator
(7.6.2.2 [<A href="https://wg21.link/expr.unary.op">expr.unary.op</A>]),</LI>
</UL>
the <I>id-expression</I> is transformed into a class member access
expression using (*this) as the object expression.

</BLOCKQUOTE>

<P><B>Additional notes (June, 2024)</B></P>

<P>Unevaluated uses in static member functions are valid (and should
not be transformed).  However, the resolution above does not address
the status quo which does perform the transformation.</P>

<P><B>Additional notes (July, 2024)</B></P>

<P>Per <A HREF="https://github.com/cplusplus/CWG/issues/573">#573</A>
and
<A HREF="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p0847r7.html">P0847R7</A> (Deducing this),
the intent was that explicit object member functions
have naming restrictions similar to other non-static member functions.
For example,
</P>

<PRE>
  struct C {
    int f(this C);
  };

  using T = decltype(C::f); //<SPAN CLASS="cmnt"> error</SPAN>
  int g = C::f(42); //<SPAN CLASS="cmnt"> error</SPAN>
</PRE>

<P>The status quo wording does not reflect that desired outcome.</P>

<P><U>Possible resolution:</U></P>

<OL>
<LI>
<P>Change in 7.5.5.1 [<A href="https://wg21.link/expr.prim.id.general#2">expr.prim.id.general</A>] paragraph 2 through 4 as follows:</P>

<BLOCKQUOTE>

If an <I>id-expression</I> E denotes a non-static non-type member of
some class C <DEL>at a point where the current class
(7.5.3 [<A href="https://wg21.link/expr.prim.this">expr.prim.this</A>]) is X and</DEL> <INS>, the following rules
apply.

E is said to <I>refer to a local member</I> of some class X if E
appears at a point where X is the current class and C is X or a base
class of X.

E has the following <I>associated cv-qualification</I> relative to
some class X:
</INS>
<UL class="ins">
<LI>If E appears in a <I>function-definition</I>,
<I>member-declarator</I>, or <I>declarator</I> that declares a member
function or member function template of X, at a point after the
optional <I>cv-qualifier-seq</I>, the associated cv-qualification is
the <I>cv-qualifier-seq</I>, if present, and otherwise empty.</LI>
<LI>Otherwise, if E appears in a <I>member-declarator</I> declaring a
non-static data member of X, at a point within the optional default
member initializer, the associated cv-qualification is empty.</LI>
<LI>Otherwise, E has no associated cv-qualification.</LI>
</UL>

<P class="ins">E has the following meaning:</P>

<UL class="ins">
<LI>If E is the <I>id-expression</I> of a class member access, see
7.6.1.5 [<A href="https://wg21.link/expr.ref">expr.ref</A>].</LI>
<LI>Otherwise, if E is a <I>qualified-id</I> that is the
un-parenthesized operand of the unary &amp; operator, see
7.6.2.2 [<A href="https://wg21.link/expr.unary.op">expr.unary.op</A>].</LI>
<LI>Otherwise, if E denotes a non-static data member with declared
type <TT>T</TT> and E is not potentially evaluated, the result is an
lvalue of type <I>cv</I> <TT>T</TT> where <I>cv</I> is empty unless E
refers to a local member of some class X, in which case <I>cv</I> is
the associated cv-qualification relative to X (if any).
[ Example:
<PRE>
  template&lt;int n&gt; class R { };
  struct S {
    int m;
    char g(int&amp;);         // <SPAN CLASS="cmnt">#1</SPAN>
    int g(const int&amp;);    // <SPAN CLASS="cmnt">#2</SPAN>
    auto f() const -&gt; R&lt;sizeof(g(m))&gt;;     // <SPAN CLASS="cmnt">OK, return type is </SPAN>R&lt;sizeof(int)&gt;
  };
  int j = sizeof(S::m + 42); //<SPAN CLASS="cmnt"> OK</SPAN>
</PRE>
-- end example ]</LI>
<LI>Otherwise, if E is refers to a local member of some class X:
<UL>
<LI>If E appears in an implicit object member function, is
potentially evaluated, and has a (possibly empty) associated
cv-qualification relative to X, E is transformed into a class member
access expression using <TT>(*this)</TT> as the object expression.
This transformation does not apply in the template definition context
(13.8.3.2 [<A href="https://wg21.link/temp.dep.type">temp.dep.type</A>]).</LI>
<LI>Otherwise, E shall not be potentially evaluated; the type and
value category of the result is as specified in
7.5.5.2 [<A href="https://wg21.link/expr.prim.id.unqual">expr.prim.id.unqual</A>] and 7.5.5.3 [<A href="https://wg21.link/expr.prim.id.qual">expr.prim.id.qual</A>].</LI>
</UL>
</LI>

<LI>Otherwise, if E denotes a member enumerator, the result is as
specified in 7.5.5.2 [<A href="https://wg21.link/expr.prim.id.unqual">expr.prim.id.unqual</A>] and
7.5.5.3 [<A href="https://wg21.link/expr.prim.id.qual">expr.prim.id.qual</A>].</LI>

<LI>Otherwise, the program is ill-formed.</LI>
</UL>

<UL class="del">
<LI>E is potentially evaluated or C is X or a base class of X,
and</LI>
<LI>E is not the <I>id-expression</I> of a class member access
expression (7.6.1.5 [<A href="https://wg21.link/expr.ref">expr.ref</A>]), and</LI>
<LI>if E is a <I>qualified-id</I>, E is not the un-parenthesized
operand of the unary &amp; operator
(7.6.2.2 [<A href="https://wg21.link/expr.unary.op">expr.unary.op</A>]),</LI>
</UL>
<P class="del">the <I>id-expression</I> is transformed into a class
member access expression using <TT>(*this)</TT> as the object
expression.  [<I>Note 2:</I> If C is not X or a base class of X, the
class member access expression is ill-formed. Also, if
the <I>id-expression</I> occurs within a static or explicit object
member function, the class member access is ill-formed. &#8212;<I>end
note</I>] This transformation does not apply in the template
definition context (13.8.3.2 [<A href="https://wg21.link/temp.dep.type">temp.dep.type</A>]).</P>

<P>
If an <I>id-expression</I> E denotes a member M of an anonymous union
(11.5.2 [<A href="https://wg21.link/class.union.anon">class.union.anon</A>]) U:
<UL>
<LI>If U is a non-static data member, E refers to M as a member of
the lookup context of the terminal name of E (after any implicit
transformation to a class member access expression).  [<I>Example
1:</I> o.x is interpreted as o.u.x, where u names the anonymous union
member. &#8212;<I>end example</I>]</LI>
<LI>Otherwise, E is interpreted
as a class member access (7.6.1.5 [<A href="https://wg21.link/expr.ref">expr.ref</A>]) that
designates the member subobject M of the anonymous union variable for
U.  [<I>Note 3:</I> Under this interpretation, E no longer denotes a
non-static data member. &#8212;<I>end note</I>] [<I>Example 2:</I>
N::x is interpreted as N::u.x, where u names the anonymous union
variable. &#8212;<I>end example</I>]</LI>
</UL>
</P>

<P class="del">An <I>id-expression</I> that denotes a non-static data member or
implicit object member function of a class can only be used:
<UL class="del">
<LI>as part of a class member access
(after any implicit transformation (see above)) in which the object
expression refers to the member's class or a class derived from that
class, or</LI>
<LI>to form a pointer to member
(7.6.2.2 [<A href="https://wg21.link/expr.unary.op">expr.unary.op</A>]), or</LI>
<LI>if that <I>id-expression</I>
denotes a non-static data member and it appears in an unevaluated
operand.  [<I>Example 3:</I>
<PRE>
  struct S { int m; };
  int i = sizeof(S::m);      //<SPAN CLASS="cmnt"> OK</SPAN>
  int j = sizeof(S::m + 42); //<SPAN CLASS="cmnt"> OK</SPAN>
</PRE>
&#8212;<I>end example</I>]</LI>
</UL>
</P>

</BLOCKQUOTE>
</LI>

<LI>
<P>Change in 7.6.1.5 [<A href="https://wg21.link/expr.ref#5">expr.ref</A>] paragraph 5 as follow:</P>

<BLOCKQUOTE>

Otherwise, the object expression shall be of class type. The class
type shall be complete unless the class member access appears in the
definition of that class.  <INS><TT>E2</TT> shall denote a member
of that class.</INS> [<I>Note 3:</I> The program is ill-formed if
the result differs from that when the class is complete
(6.5.2 [<A href="https://wg21.link/class.member.lookup">class.member.lookup</A>]). &#8212;<I>end note</I>] [<I>Note 4:</I>
6.5.5 [<A href="https://wg21.link/basic.lookup.qual">basic.lookup.qual</A>] describes how names are looked up after the
. and -&gt; operators. &#8212;<I>end note</I>]

</BLOCKQUOTE>
</LI>
</OL>
<BR><BR>
</BODY>
</HTML>
