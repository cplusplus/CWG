<HTML>
<HEAD>
<meta http-equiv="Content-Type" content="text/html; charset=us-ascii">
<TITLE>
    CWG Issue 623</TITLE>
<STYLE TYPE="text/css">
  INS { text-decoration:none; font-weight:bold; background-color:#A0FFA0 }
  .INS { text-decoration:none; background-color:#D0FFD0 }
  DEL { text-decoration:line-through; background-color:#FFA0A0 }
  .DEL { text-decoration:line-through; background-color: #FFD0D0 }
  SPAN.cmnt { font-family:Times; font-style:italic }
</STYLE>
</HEAD>
<BODY>
<P><EM>This is an unofficial snapshot of the ISO/IEC JTC1 SC22 WG21
  Core Issues List revision 116.
  See http://www.open-std.org/jtc1/sc22/wg21/ for the official
  list.</EM></P>
<P>2024-12-19</P>
<HR>
<A NAME="623"></A><H4>623.
  
Use of pointers to deallocated storage
</H4>
<B>Section: </B>6.7.6.5.3&#160; [<A href="https://wg21.link/basic.stc.dynamic.deallocation">basic.stc.dynamic.deallocation</A>]
 &#160;&#160;&#160;

 <B>Status: </B>CD3
 &#160;&#160;&#160;

 <B>Submitter: </B>Herb Sutter
 &#160;&#160;&#160;

 <B>Date: </B>27 February 2007<BR>




<P>Any use of a pointer to deleted storage, even if the pointer is not
dereferenced, produces undefined behavior (6.7.6.5.3 [<A href="https://wg21.link/basic.stc.dynamic.deallocation#4">basic.stc.dynamic.deallocation</A>] paragraph 4)
.  The reason for this restriction is that, on some historical
architectures, deallocating an object might free a memory segment,
resulting in a hardware exception if a pointer referring to that segment
were loaded into a pointer register, and on those architectures use of a
pointer register for moving and comparing pointers was the most efficient
mechanism for these operations.</P>

<P>It is not clear whether current or foreseeable architectures still
require such a draconian restriction or whether it is feasible to relax
it only to forbid a smaller range of operations.  Of particular concern
is the use of atomic pointers, which might be used in race conditions
involving deallocation, where the loser of the race might encounter this
undefined behavior.</P>

<P>(See also <A HREF="312.html">issue 312</A>.)</P>

<P><B>Rationale (April, 2007):</B></P>

<P>The current specification is clear and was well-motivated.
Analysis of whether this restriction is still needed should be done
via a paper and discussed in the Evolution Working Group rather than
being handled by CWG as an issue/defect.</P>

<P><B>Additional note, February, 2014:</B></P>

<P>This issue was resolved by the resolution of
<A HREF="616.html">issue 616</A>, which made use of a pointer to
deleted storage implementation-defined behavior.</P>

<BR><BR>
</BODY>
</HTML>
