<HTML>
<HEAD>
<meta http-equiv="Content-Type" content="text/html; charset=us-ascii">
<TITLE>
    CWG Issue 636</TITLE>
<STYLE TYPE="text/css">
  INS { text-decoration:none; font-weight:bold; background-color:#A0FFA0 }
  .INS { text-decoration:none; background-color:#D0FFD0 }
  DEL { text-decoration:line-through; background-color:#FFA0A0 }
  .DEL { text-decoration:line-through; background-color: #FFD0D0 }
  SPAN.cmnt { font-family:Times; font-style:italic }
</STYLE>
</HEAD>
<BODY>
<P><EM>This is an unofficial snapshot of the ISO/IEC JTC1 SC22 WG21
  Core Issues List revision 116b.
  See http://www.open-std.org/jtc1/sc22/wg21/ for the official
  list.</EM></P>
<P>2025-03-05</P>
<HR>
<A NAME="636"></A><H4>636.
  
Dynamic type of objects and aliasing
</H4>
<B>Section: </B>7.2.1&#160; [<A href="https://wg21.link/basic.lval">basic.lval</A>]
 &#160;&#160;&#160;

 <B>Status: </B>CD4
 &#160;&#160;&#160;

 <B>Submitter: </B>Gabriel Dos Reis
 &#160;&#160;&#160;

 <B>Date: </B>23 May 2007<BR>




<P>The aliasing rules given in 7.2.1 [<A href="https://wg21.link/basic.lval">basic.lval</A>] paragraph
10 rely on the concept of &#8220;dynamic type.&#8221;  The problem is
that the dynamic type of an object often cannot be determined (or
even sufficiently constrained) at the point at which an optimizer
needs to be able to determine whether aliasing might occur or not.
For example, consider the function</P>

<PRE>
    void foo(int* p, double* q) {
        *p = 42;
        *q = 3.14;
    }
</PRE>

<P>An optimizer, on the basis of the existing aliasing rules, might
decide that an <TT>int*</TT> and a <TT>double*</TT> cannot
refer to the same object and reorder the assignments.  This
reordering, however, could result in undefined behavior if the
function <TT>foo</TT> is called as follows:</P>

<PRE>
   void goo() {
      union {
         int i;
         double d;
      } t;

      t.i = 12;

      foo(&amp;t.i, &amp;t.d);

      cout &lt;&lt; t.d &lt;&lt; endl;
   };
</PRE>

<P>Here, the reference to <TT>t.d</TT> after the call to
<TT>foo</TT> will be valid only if the assignments in
<TT>foo</TT> are executed in the order in which they were
written; otherwise, the union will contain an <TT>int</TT>
object rather than a <TT>double</TT>.</P>

<P>One possibility would be to require that if such aliasing
occurs, it be done only via member names and not via
pointers.</P>

<P><B>Notes from the July, 2007 meeting:</B></P>

<P>This is the same issue as C's <A href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/dr_236.htm">DR236</A>.
The CWG expressed a desire to address the issue the same way C99
does.  The issue also occurs in C++ when placement new is used to
end the lifetime of one object and start the lifetime of a different
object occupying the same storage.</P>



<P><B>Proposed resolution (March, 2017):</B></P>

<P>This issue is resolved by the resolution of
<A HREF="1776.html">issue 1776</A>.</P>

<BR><BR>
</BODY>
</HTML>
