<HTML>
<HEAD>
<meta http-equiv="Content-Type" content="text/html; charset=us-ascii">
<TITLE>
    CWG Issue 2335</TITLE>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<STYLE TYPE="text/css">
  INS { text-decoration:none; font-weight:bold; background-color:#A0FFA0 }
  .INS { text-decoration:none; background-color:#D0FFD0 }
  DEL { text-decoration:line-through; background-color:#FFA0A0 }
  .DEL { text-decoration:line-through; background-color: #FFD0D0 }
  @media (prefers-color-scheme: dark) {
    HTML { background-color:#202020; color:#f0f0f0; }
    A { color:#5bc0ff; }
    A:visited { color:#c6a8ff; }
    A:hover, a:focus { color:#afd7ff; }
    INS { background-color:#033a16; color:#aff5b4; }
    .INS { background-color: #033a16; }
    DEL { background-color:#67060c; color:#ffdcd7; }
    .DEL { background-color:#67060c; }
  }
  SPAN.cmnt { font-family:Times; font-style:italic }
</STYLE>
</HEAD>
<BODY>
<P><EM>This is an unofficial snapshot of the ISO/IEC JTC1 SC22 WG21
  Core Issues List revision 116c.
  See http://www.open-std.org/jtc1/sc22/wg21/ for the official
  list.</EM></P>
<P>2025-03-08</P>
<HR>
<A NAME="2335"></A><H4>2335.
  
Deduced return types vs member types
</H4>
<B>Section: </B>11.4.9.3&#160; [<A href="https://wg21.link/class.static.data">class.static.data</A>]
 &#160;&#160;&#160;

 <B>Status: </B>drafting
 &#160;&#160;&#160;

 <B>Submitter: </B>John Spicer
 &#160;&#160;&#160;

 <B>Date: </B>2017-01-29<BR>


<P>It is not clear how an example like the following should be
treated:</P>

<PRE>
  template &lt;class ...&gt; struct partition_indices {
    static auto compute_right () {}
    static constexpr auto right = compute_right;
  };
  auto foo () -&gt; partition_indices&lt;&gt;;
  void f() {
    foo();
  };
</PRE>

<P>The initialization of <TT>right</TT> is in a context that must
be done during the initial parse of the class, but the function
body of <TT>compute_right</TT> is not supposed to be evaluated
until the class is complete. Current implementations appear to
accept the template case but not the equivalent non-template case.
It's not clear why those cases should be treated differently.</P>

<P>If you change the example to include a forward dependency in
the body of <TT>compute_right</TT>, e.g.,</P>

<PRE>
  template &lt;int&gt; struct X {};
  template &lt;class T&gt; struct partition_indices {
    static auto compute_right () { return X&lt;I&gt;(); }
    static constexpr auto right = compute_right;
    static constexpr int I = sizeof(T);
  };

  auto foo () -&gt; partition_indices&lt;int&gt;;

  void f() {
    foo();
  };
</PRE>

<P>current implementations reject the code, but it's not clear
that there is a rationale for the different behavior.</P>

<P><B>Notes from the March, 2018 meeting:</B></P>

<P>It was proposed that one direction might be to disallow instantiating
member functions while the containing class template is being instantiated.
However, overnight implementation experience indicated that this approach
breaks seemingly-innocuous and currently-accepted code like:</P>

<PRE>
  template &lt;class T&gt; struct A {
    static constexpr int num() { return 42; }
    int ar[num()];
  };
  A&lt;int&gt; a;
</PRE>

<P>There was divergence of opinion regarding whether the current
rules describe the current behavior for the two original examples
or whether additional explicit rules are needed to clarify the difference
in behavior between template and non-template examples, as well as
whether there should be a difference at all..</P>

<P><B>Notes from the June, 2018 meeting:</B></P>

<P>The consensus of CWG was to treat templates and classes the same by
"instantiating" delayed-parse regions when they are needed instead of at
the end of the class.</P>

<P>See also issues <A HREF="1626.html">1626</A> and
<A HREF="1890.html">1890</A>.</P>

<BR><BR>
</BODY>
</HTML>
