<HTML>
<HEAD>
<meta http-equiv="Content-Type" content="text/html; charset=us-ascii">
<TITLE>
    CWG Issue 2397</TITLE>
<STYLE TYPE="text/css">
  INS { text-decoration:none; font-weight:bold; background-color:#A0FFA0 }
  .INS { text-decoration:none; background-color:#D0FFD0 }
  DEL { text-decoration:line-through; background-color:#FFA0A0 }
  .DEL { text-decoration:line-through; background-color: #FFD0D0 }
  SPAN.cmnt { font-family:Times; font-style:italic }
</STYLE>
</HEAD>
<BODY>
<P><EM>This is an unofficial snapshot of the ISO/IEC JTC1 SC22 WG21
  Core Issues List revision 116.
  See http://www.open-std.org/jtc1/sc22/wg21/ for the official
  list.</EM></P>
<P>2024-12-19</P>
<HR>
<A NAME="2397"></A><H4>2397.
  
<TT>auto</TT> specifier for pointers and references to arrays
</H4>
<B>Section: </B>9.3.4.5&#160; [<A href="https://wg21.link/dcl.array">dcl.array</A>]
 &#160;&#160;&#160;

 <B>Status: </B>CD6
 &#160;&#160;&#160;

 <B>Submitter: </B>Hubert Tong
 &#160;&#160;&#160;

 <B>Date: </B>2019-02-04<BR>


<P>[Accepted as a DR at the June, 2021 meeting.]</P>

<P>According to 9.3.4.5 [<A href="https://wg21.link/dcl.array#1">dcl.array</A>] paragraph 1,</P>

<BLOCKQUOTE>

<P>In a declaration <TT>T D</TT> where <TT>D</TT> has the
form</P>

<UL>
<TT>D1 [</TT> <I>constant-expression<SUB>opt</SUB></I> <TT>]</TT> <I>attribute-specifier-seq<SUB>opt</SUB></I>
</UL>

<P>and the type of the identifier in the declaration <TT>T
D1</TT> is
&#8220;<I>derived-declarator-type-list</I> <TT>T</TT>&#8221;,
then the type of the identifier of <TT>D</TT> is an array
type; if the type of the identifier of <TT>D</TT> contains
the <TT>auto</TT> <I>type-specifier</I>, the program is
ill-formed.</P>

</BLOCKQUOTE>

<P>This formulation forbids useful constructs like</P>

<PRE>
  int a[3];
  auto (*p)[3] = &amp;a;
</PRE>

<P>(accepted by current implementations) and should be
relaxed to accommodate such cases.</P>

<P><B>Notes from the February, 2019 meeting:</B></P>

<P>CWG agreed that the example should be accepted.</P>

<P><B>Notes from the May 25, 2021 teleconference:</B></P>

<P>It was observed that CWG rejected the same example as
being "not a defect" in considering <A HREF="1222.html">issue 1222</A>. However, the use of <TT>auto</TT> has
significantly expanded since that time and the prohibition
of such declarations now seems inconsistent.</P>

<P><B>Proposed resolution, May, 2021:</B></P>

<OL>
<LI><P>Change 9.3.4.5 [<A href="https://wg21.link/dcl.array#4">dcl.array</A>] paragraph 4 as
follows:</P></LI>

<BLOCKQUOTE>

<TT>U</TT> is called the array element type; this type shall
not be <DEL>a placeholder type
(9.2.9.7 [<A href="https://wg21.link/dcl.spec.auto">dcl.spec.auto</A>]),</DEL> a reference type, a
function type, an array of unknown bound,
or <I>cv</I> <TT>void</TT>.

</BLOCKQUOTE>

<LI><P>Change 9.3.4.6 [<A href="https://wg21.link/dcl.fct#11">dcl.fct</A>] paragraph 11 as follows:</P></LI>

<BLOCKQUOTE>

The return type shall be a non-array object type, a
reference type, or <I>cv</I> <TT>void</TT>. <INS>[<I>Note:</I>
An array of placeholder type is considered an array type.
&#8212;<I>end note</I>]</INS>

</BLOCKQUOTE>

<LI><P>Change 9.2.9.7.2 [<A href="https://wg21.link/dcl.type.auto.deduct#2">dcl.type.auto.deduct</A>] paragraph 2 as follows:</P></LI>

<BLOCKQUOTE>

<P>A type <TT>T</TT>
containing a placeholder type, and a corresponding
initializer <I>E</I>, are determined as follows:</P>

<UL>
<LI><P>for a non-discarded <TT>return</TT> statement
that occurs in a function declared with a return type that
contains a placeholder type, <TT>T</TT> is the declared
return type and <I>E</I> is the operand of
the <TT>return</TT> statement. If the <TT>return</TT>
statement has no operand, then <I>E</I>
is <TT>void()</TT>;</P></LI>

<LI><P>for a variable declared with a type that contains a
placeholder type, <TT>T</TT> is the declared type of the
variable and <I>E</I> is the initializer. If the
initialization is direct-list-initialization, the
initializer shall be a <I>braced-init-list</I> containing
only a single <I>assignment-expression</I> and <I>E</I> is
the <I>assignment-expression</I>;</P></LI>

<LI><P>for a non-type template parameter declared with a
type that contains a placeholder type, <TT>T</TT> is the
declared type of the non-type template parameter
and <I>E</I> is the corresponding template
argument.</P></LI>

</UL>

<P>
<INS><TT>T</TT> shall not be an array type.</INS> In the
case of a <TT>return</TT> statement with no operand...</P>

</BLOCKQUOTE>

</OL>

<BR><BR>
</BODY>
</HTML>
