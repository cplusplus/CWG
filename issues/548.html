<HTML>
<HEAD>
<meta http-equiv="Content-Type" content="text/html; charset=us-ascii">
<TITLE>
    CWG Issue 548</TITLE>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<STYLE TYPE="text/css">
  INS { text-decoration:none; font-weight:bold; background-color:#A0FFA0 }
  .INS { text-decoration:none; background-color:#D0FFD0 }
  DEL { text-decoration:line-through; background-color:#FFA0A0 }
  .DEL { text-decoration:line-through; background-color: #FFD0D0 }
  @media (prefers-color-scheme: dark) {
    HTML { background-color:#202020; color:#f0f0f0; }
    A { color:#5bc0ff; }
    A:visited { color:#c6a8ff; }
    A:hover, a:focus { color:#afd7ff; }
    INS { background-color:#033a16; color:#aff5b4; }
    .INS { background-color: #033a16; }
    DEL { background-color:#67060c; color:#ffdcd7; }
    .DEL { background-color:#67060c; }
  }
  SPAN.cmnt { font-family:Times; font-style:italic }
</STYLE>
</HEAD>
<BODY>
<P><EM>This is an unofficial snapshot of the ISO/IEC JTC1 SC22 WG21
  Core Issues List revision 116c.
  See http://www.open-std.org/jtc1/sc22/wg21/ for the official
  list.</EM></P>
<P>2025-03-08</P>
<HR>
<A NAME="548"></A><H4>548.
  
<I>qualified-id</I>s in declarations
</H4>
<B>Section: </B>9.3.4&#160; [<A href="https://wg21.link/dcl.meaning">dcl.meaning</A>]
 &#160;&#160;&#160;

 <B>Status: </B>dup
 &#160;&#160;&#160;

 <B>Submitter: </B>Martin Sebor
 &#160;&#160;&#160;

 <B>Date: </B>18 November 2005<BR>


<P>According to 9.3.4 [<A href="https://wg21.link/dcl.meaning#1">dcl.meaning</A>] paragraph 1, the declarator
in the definition or explicit instantiation of a namespace member can
only be qualified if the definition or explicit instantiation appears
outside the member's namespace:</P>

<BLOCKQUOTE>

A <I>declarator-id</I> shall not be qualified except for the
definition of a member function (11.4.2 [<A href="https://wg21.link/class.mfct">class.mfct</A>]) or static
data member (11.4.9 [<A href="https://wg21.link/class.static">class.static</A>]) outside of its class, the
definition or explicit instantiation of a function or variable member
of a namespace outside of its namespace, or the definition of a
previously declared explicit specialization outside of its namespace,
or the declaration of a friend function that is a member of another
class or namespace (11.8.4 [<A href="https://wg21.link/class.friend">class.friend</A>]). When
the <I>declarator-id</I> is qualified, the declaration shall refer to
a previously declared member of the class or namespace to which the
qualifier refers, and the member shall not have been introduced by
a <I>using-declaration</I> in the scope of the class or namespace
nominated by the <I>nested-name-specifier</I> of
the <I>declarator-id</I>.

</BLOCKQUOTE>

<P>There is no similar restriction on a <I>qualified-id</I> in a
class definition (Clause 11 [<A href="https://wg21.link/class#5">class</A>] paragraph 5):</P>

<BLOCKQUOTE>

If a <I>class-head</I> contains a <I>nested-name-specifier</I>,
the <I>class-specifier</I> shall refer to a class that was previously
declared directly in the class or namespace to which the
<I>nested-name-specifier</I> refers (i.e., neither inherited nor
introduced by a <I>using-declaration</I>), and
the <I>class-specifier</I> shall appear in a namespace enclosing the
previous declaration.

</BLOCKQUOTE>

<P>An <I>elaborated-type-specifier</I> in an explicit instatiation
containing a <I>qualified-id</I> is also not prohibited from appearing
in the namespace nominated by its <I>nested-name-specifier</I>
(13.9.3 [<A href="https://wg21.link/temp.explicit#2">temp.explicit</A>] paragraph 2):</P>

<BLOCKQUOTE>

An explicit instantiation shall appear in an enclosing namespace of
its template. If the name declared in the explicit instantiation is an
unqualified name, the explicit instantiation shall appear in the
namespace where its template is declared.

</BLOCKQUOTE>

<P>(This asymmetry is due to the removal of inappropriate mention
of classes in 9.3.4 [<A href="https://wg21.link/dcl.meaning">dcl.meaning</A>] by
<A HREF="40.html">issue 40</A> and a failure to insert the
intended restrictions elsewhere.)</P>

<P>An example of this inconsistency is:</P>

<PRE>
    namespace N {
      template &lt;class T&gt; struct S { };
      template &lt;class T&gt; void foo () { }

      template struct N::S&lt;int&gt;;   //<SPAN CLASS="cmnt"> OK</SPAN>
      template void N::foo&lt;int&gt;(); //<SPAN CLASS="cmnt"> ill-formed</SPAN>
    }
</PRE>

<P>It is not clear that any purpose is served by the &#8220;outside of
its namespace&#8221; restriction on declarators in definitions and
explicit instantiations; if possible, it would be desirable to
reconcile the treatment of declarators and class names by removing
the restriction on declarators (which appears to be widespread
implementation practice, anyway).</P>

<P><B>Rationale (April, 2006):</B></P>

<P>This is the same as <A HREF="482.html">issue 482</A>.</P>

<BR><BR>
</BODY>
</HTML>
