<HTML>
<HEAD>
<meta http-equiv="Content-Type" content="text/html; charset=us-ascii">
<TITLE>
    CWG Issue 2047</TITLE>
<STYLE TYPE="text/css">
  INS { text-decoration:none; font-weight:bold; background-color:#A0FFA0 }
  .INS { text-decoration:none; background-color:#D0FFD0 }
  DEL { text-decoration:line-through; background-color:#FFA0A0 }
  .DEL { text-decoration:line-through; background-color: #FFD0D0 }
  SPAN.cmnt { font-family:Times; font-style:italic }
</STYLE>
</HEAD>
<BODY>
<P><EM>This is an unofficial snapshot of the ISO/IEC JTC1 SC22 WG21
  Core Issues List revision 116b.
  See http://www.open-std.org/jtc1/sc22/wg21/ for the official
  list.</EM></P>
<P>2025-03-05</P>
<HR>
<A NAME="2047"></A><H4>2047.
  
Coordinating &#8220;throws anything&#8221; specifications
</H4>
<B>Section: </B>14.5&#160; [<A href="https://wg21.link/except.spec">except.spec</A>]
 &#160;&#160;&#160;

 <B>Status: </B>CD4
 &#160;&#160;&#160;

 <B>Submitter: </B>Richard Smith
 &#160;&#160;&#160;

 <B>Date: </B>2014-11-18<BR>


<P>[Adopted at the February, 2016 meeting.]</P>



<P>The resolutions of issues <A HREF="330.html">330</A> and
<A HREF="1351.html">1351</A> use different terminology for an
exception specification that can throw anything: the former
refers to a &#8220;(conceptual) set of all types,&#8221; while the
latter uses a &#8220;pseudo-type, denoted by 'any'.&#8221;  These
should be unified.</P>

<P><B>Proposed resolution (October, 2015) [SUPERSEDED]:</B></P>

<OL>
<LI><P>Change 14.5 [<A href="https://wg21.link/except.spec#13">except.spec</A>] paragraph 13 as follows:</P></LI>

<BLOCKQUOTE>

<DEL>A</DEL> <INS>The <I>set of</I></INS> <I>potential
exception<INS>s</INS></I> of a given context is <DEL>either
a type</DEL> <INS>a set of types</INS> that might be thrown
as an exception<DEL> or a pseudo-type, denoted by
&#8220;any&#8221;, that represents the situation where an
exception of an arbitrary type might be thrown</DEL><INS>; the
(conceptual) set of all types is used to denote that an
exception of arbitrary type might be thrown</INS>. A
subexpression <TT>e1</TT> of an expression <TT>e</TT> is
an <I>immediate subexpression</I> if there is no
subexpression <TT>e2</TT> of <TT>e</TT> such that
<TT>e1</TT> is a subexpression of <TT>e2</TT>.

</BLOCKQUOTE>

<LI><P>Delete 14.5 [<A href="https://wg21.link/except.spec#14">except.spec</A>] paragraph 14:</P></LI>

<BLOCKQUOTE>

<P><DEL>The <I>set of potential exceptions of a function,
function pointer, or member function pointer</I> <TT>f</TT>
is defined as follows:</DEL></P>

<UL>
<LI><P><DEL>If the exception specification of <TT>f</TT> is the set of
all types, the set consists of the pseudo-type
&#8220;any&#8221;.</DEL></P></LI>

<LI><P><DEL>Otherwise, the set consists of every type in the exception
specification of <TT>f</TT>.</DEL></P></LI>

</UL>

</BLOCKQUOTE>

<LI><P>Change 14.5 [<A href="https://wg21.link/except.spec#15">except.spec</A>] paragraph 15 as follows:</P></LI>

<BLOCKQUOTE>

<P>The <I>set of potential exceptions of an
expression</I> <TT>e</TT> is empty if <TT>e</TT> is a core
constant expression (7.7 [<A href="https://wg21.link/expr.const">expr.const</A>]). Otherwise,
it is the union of the sets of potential exceptions of the
immediate subexpressions of <TT>e</TT>, including default
argument expressions used in a function call, combined with
a set <I>S</I> defined by the form of <TT>e</TT>, as
follows:</P>

<UL>
<LI><P>If e is a function call
(7.6.1.3 [<A href="https://wg21.link/expr.call">expr.call</A>]):</P></LI>

<UL>
<LI><P>If its <I>postfix-expression</I> is a (possibly
parenthesized) <I>id-expression</I>
(_N4567_.5.1.1 [<A href="https://wg21.link/expr.prim.general">expr.prim.general</A>]), class member access
(7.6.1.5 [<A href="https://wg21.link/expr.ref">expr.ref</A>]), or pointer-to-member operation
(7.6.4 [<A href="https://wg21.link/expr.mptr.oper">expr.mptr.oper</A>]) whose <I>cast-expression</I> is
an <I>id-expression</I>, <I>S</I> is the set
of <DEL>potential exceptions</DEL> <INS>types in the
exception specification</INS> of the entity selected by the
contained <I>id-expression</I> (after overload resolution,
if applicable).</P></LI>

<LI><P>Otherwise, <I>S</I> <DEL>contains the pseudo-type
&#8220;any&#8221;</DEL> <INS>is the set of all
types</INS>.</P></LI>

</UL>

<LI><P>If <TT>e</TT> implicitly invokes a function (such as
an overloaded operator, an allocation function in
a <I>new-expression</I>, or a destructor if <TT>e</TT> is a
full-expression (6.9.1 [<A href="https://wg21.link/intro.execution">intro.execution</A>])), <I>S</I> is the
set of <DEL>potential exceptions</DEL> <INS>types in the
exception specification</INS> of the function.</P></LI>

<LI><P>if <TT>e</TT> is a <I>throw-expression</I>
(7.6.18 [<A href="https://wg21.link/expr.throw">expr.throw</A>]), <I>S</I> consists of the type
of the exception object that would be initialized by the
operand, if present, or <INS>is</INS> the <DEL>pseudo-type
&#8220;any&#8221;</DEL> <INS>set of all types</INS>
otherwise.</P></LI>

<LI><P>if <TT>e</TT> is a <TT>dynamic_cast</TT> expression
that casts to a reference type and requires a run-time check
(7.6.1.7 [<A href="https://wg21.link/expr.dynamic.cast">expr.dynamic.cast</A>]), <I>S</I> consists of the type
<TT>std::bad_cast</TT>.</P></LI>

<LI><P>if <TT>e</TT> is a <TT>typeid</TT> expression applied
to a glvalue expression whose type is a polymorphic class
type (7.6.1.8 [<A href="https://wg21.link/expr.typeid">expr.typeid</A>]), <I>S</I> consists of the type
<TT>std::bad_typeid</TT>.</P></LI>

<LI><P>if <TT>e</TT> is a <I>new-expression</I> with a non-constant
expression in the <I>noptr-new-declarator</I>
(7.6.2.8 [<A href="https://wg21.link/expr.new">expr.new</A>]), <I>S</I> consists of the type
<TT>std::bad_array_new_length</TT>.</P></LI>

</UL>
<P>[<I>Example:</I> Given the following declarations</P>

<PRE>
  void f() throw(int);
  void g();
  struct A { A(); };
  struct B { B() noexcept; };
  struct D<DEL>()</DEL> { D() throw (double); };
</PRE>

<P>the set of potential exceptions for some sample expressions
is:</P>

<UL>
<LI><P>for <TT>f()</TT>, the set consists
of <TT>int</TT>;</P></LI>

<LI><P>for <TT>g()</TT>, the set <DEL>consists of
&#8220;any&#8221;</DEL> <INS>is the set of all types</INS>;</P></LI>

<LI><P>for <TT>new A</TT>, the set <DEL>consists of
&#8220;any&#8221;</DEL> <INS>is the set of all types</INS>;</P></LI>

<LI><P>for <TT>B()</TT>, the set is empty;</P></LI>

<LI><P>for <TT>new D</TT>, the set <DEL>consists of
&#8220;any&#8221; and <TT>double</TT></DEL>
<INS>is the set of all types</INS>. <INS>[<I>Note:</I> This set
conceptually includes the type <TT>double</TT>.
&#8212;<I>end note</I>]</INS>
</P></LI>

</UL>

<P>&#8212;<I>end example</I>]</P>

</BLOCKQUOTE>

<LI><P>Change 14.5 [<A href="https://wg21.link/except.spec#16">except.spec</A>] paragraph 16 as follows:</P></LI>

<BLOCKQUOTE>

<DEL>Given a</DEL> <INS>A</INS> member function <TT>f</TT> of
some class <TT>X</TT>, where <TT>f</TT> is an inheriting
constructor (_N4527_.12.9 [<A href="https://wg21.link/class.inhctor">class.inhctor</A>]) or an
implicitly-declared special member function, <DEL>the <I>set
of potential exceptions of the implicitly-declared member
function</I> <TT>f</TT></DEL> <INS>is considered to have an
implicit exception specification that</INS> consists of all
the members from the following sets...

</BLOCKQUOTE>

<LI><P>Delete the normative portion of 14.5 [<A href="https://wg21.link/except.spec#17">except.spec</A>] paragraph 17
and merge the note and example into the preceding
paragraph, as follows:</P></LI>

<BLOCKQUOTE>

<P><DEL>An inheriting constructor (_N4527_.12.9 [<A href="https://wg21.link/class.inhctor">class.inhctor</A>]) and an
implicitly-declared special member function (
11.4.4 [<A href="https://wg21.link/special">special</A>]) are considered to have an implicit
exception specification, as follows, where <I>S</I> is the set of
potential exceptions of the implicitly-declared member
function:</DEL></P>

<UL>
<LI><P><DEL>if <I>S</I> contains the pseudo-type &#8220;any&#8221;, the
implicit exception specification is the set of all types;</DEL></P></LI>

<LI><P><DEL>otherwise, the implicit exception specification contains all
the types in <I>S</I>.</DEL></P></LI>

</UL>

<P>[<I>Note:</I> An instantiation of an inheriting constructor
template...</P>

</BLOCKQUOTE>

</OL>

<P><B>Additional note (November, 2015):</B></P>

<P>The base text underlying the preceding proposed resolution was
changed at the October, 2015 meeting by the adoption of paper
P0136R1. As a result, this issue has been returned to "drafting"
status to allow reconciliation of the two sets of changes.</P>

<P><B>Proposed resolution (January, 2016):</B></P>

<OL>
<LI><P>Change 14.5 [<A href="https://wg21.link/except.spec#12">except.spec</A>] paragraph 12 as follows:</P></LI>

<BLOCKQUOTE>

<DEL>A</DEL> <INS>The <I>set of</I></INS> <I>potential
exception<INS>s</INS></I> of a given context is <DEL>either
a type</DEL> <INS>a set of types</INS> that might be thrown
as an exception <DEL>or a pseudo-type, denoted by
&#8220;any&#8221;, that represents the situation where an
exception of an arbitrary type might be thrown</DEL><INS>;
the (conceptual) set of all types is used to denote that an
exception of arbitrary type might be thrown</INS>. A
subexpression <TT>e1</TT> of an expression <TT>e</TT> is
an <I>immediate subexpression</I> if there is no
subexpression <TT>e2</TT> of <TT>e</TT> such that
<TT>e1</TT> is a subexpression of <TT>e2</TT>.

</BLOCKQUOTE>

<LI><P>Delete 14.5 [<A href="https://wg21.link/except.spec#13">except.spec</A>] paragraph 13:</P></LI>

<BLOCKQUOTE>

<P><DEL>The set of potential exceptions of a function,
function pointer, or member function pointer <TT>f</TT> is defined as
follows:</DEL></P>

<UL>
<LI><P><DEL>If the exception specification of <TT>f</TT> is the
set of all types, the set consists of the pseudo-type
&#8220;any&#8221;.</DEL></P></LI>

<LI><P><DEL>Otherwise, the set consists of every type in the exception
specification of <TT>f</TT>.</DEL></P></LI>

</UL>

</BLOCKQUOTE>

<LI><P>Change 14.5 [<A href="https://wg21.link/except.spec#14">except.spec</A>] paragraph 14 as follows:</P></LI>

<BLOCKQUOTE>

<P>The <I>set of potential exceptions of an
expression</I> <TT>e</TT> is empty if <TT>e</TT> is a core constant
expression (7.7 [<A href="https://wg21.link/expr.const">expr.const</A>]). Otherwise, it is the
union of the sets of potential exceptions of the immediate
subexpressions of <TT>e</TT>, including default argument expressions
used in a function call, combined with a set <I>S</I> defined by
the form of <TT>e</TT>, as follows:</P>

<UL>
<LI><P>If <TT>e</TT> is a function call
(7.6.1.3 [<A href="https://wg21.link/expr.call">expr.call</A>]):</P></LI>

<UL>
<LI><P>If its <I>postfix-expression</I> is a (possibly
parenthesized) <I>id-expression</I>
(_N4567_.5.1.1 [<A href="https://wg21.link/expr.prim.general">expr.prim.general</A>]), class member access
(7.6.1.5 [<A href="https://wg21.link/expr.ref">expr.ref</A>]), or pointer-to-member operation
(7.6.4 [<A href="https://wg21.link/expr.mptr.oper">expr.mptr.oper</A>]) whose <I>cast-expression</I> is
an <I>id-expression</I>, <I>S</I> is the set
of <DEL>potential exceptions</DEL> <INS>types in the
exception specification</INS> of the entity selected by the
contained <I>id-expression</I> (after overload resolution,
if applicable).</P></LI>

<LI><P>Otherwise, if the <I>postfix-expression</I> has type
&#8220;<TT>noexcept</TT> function&#8221; or &#8220;pointer to
<TT>noexcept</TT> function&#8221;, <I>S</I> is the empty set.</P></LI>

<LI><P>Otherwise, <I>S</I> <DEL>contains the pseudo-type
&#8220;any&#8221;</DEL> <INS>is the set of all
types</INS>.</P></LI>

</UL>

<LI><P>If <TT>e</TT> implicitly invokes a function (such as
an overloaded operator, an allocation function in
a <I>new-expression</I>, or a destructor if <TT>e</TT> is a
full-expression (6.9.1 [<A href="https://wg21.link/intro.execution">intro.execution</A>])), <I>S</I> is the
set of <DEL>potential exceptions</DEL> <INS>types in the
exception specification</INS> of the function.</P></LI>

<LI><P>If <TT>e</TT> initializes an object of
type <TT>D</TT> using an inherited constructor for a class
of type <TT>B</TT> (11.9.4 [<A href="https://wg21.link/class.inhctor.init">class.inhctor.init</A>]), <I>S</I>
also contains the sets of potential exceptions of the
implied constructor invocations for subobjects of <TT>D</TT>
that are not subobjects of <TT>B</TT> (including default
argument expressions used in such invocations) as selected
by overload resolution, and the sets of potential exceptions
of the initialization of non-static data members
from <I>brace-or-equal-initializer</I>s
(11.9.3 [<A href="https://wg21.link/class.base.init">class.base.init</A>]).</P></LI>

<LI><P>If <TT>e</TT> is a <I>throw-expression</I>
(7.6.18 [<A href="https://wg21.link/expr.throw">expr.throw</A>]), <I>S</I> consists of the type
of the exception object that would be initialized by the
operand, if present, or <INS>is</INS> the <DEL>pseudo-type
&#8220;any&#8221;</DEL> <INS>set of all types</INS>
otherwise.</P></LI>

<LI><P>If <TT>e</TT> is a <TT>dynamic_cast</TT> expression
that casts to a reference type and requires a run-time check
(7.6.1.7 [<A href="https://wg21.link/expr.dynamic.cast">expr.dynamic.cast</A>]), <I>S</I> consists of the type
<TT>std::bad_cast</TT>.</P></LI>

<LI><P>If <TT>e</TT> is a <TT>typeid</TT> expression applied
to a glvalue expression whose type is a polymorphic class
type (7.6.1.8 [<A href="https://wg21.link/expr.typeid">expr.typeid</A>]), <I>S</I> consists of the type
<TT>std::bad_typeid</TT>.</P></LI>

<LI><P>If <TT>e</TT> is a <I>new-expression</I> with a non-constant
expression in the <I>noptr-new-declarator</I>
(7.6.2.8 [<A href="https://wg21.link/expr.new">expr.new</A>]), <I>S</I> consists of the type
<TT>std::bad_array_new_length</TT>.</P></LI>

</UL>

<P>[<I>Example:</I> Given the following declarations</P>

<PRE>
  void f() throw(int);
  void g();
  struct A { A(); };
  struct B { B() noexcept; };
  struct D { D() throw (double); };
</PRE>

<P>the set of potential exceptions for some sample expressions
is:</P>

<UL>
<LI><P>for <TT>f()</TT>, the set consists of <TT>int</TT>;</P></LI>

<LI><P>for <TT>g()</TT>, the set <DEL>consists of &#8220;any&#8221;</DEL>
<INS>is the set of all types</INS>;</P></LI>

<LI><P>for <TT>new A</TT>, the set <DEL>consists of &#8220;any&#8221;</DEL>
<INS>is the set of all types</INS>;</P></LI>

<LI><P>for <TT>B()</TT>, the set is empty;</P></LI>

<LI><P>for <TT>new D</TT>, the set <DEL>consists of
&#8220;any&#8221; and <TT>double</TT></DEL> <INS>is the set
of all types</INS>.</P></LI>

</UL>

<P>&#8212;<I>end example</I>]</P>

</BLOCKQUOTE>

<LI><P>Change 14.5 [<A href="https://wg21.link/except.spec#16">except.spec</A>] paragraph 16 as follows:</P></LI>

<BLOCKQUOTE>

<DEL>Given an</DEL> <INS>An</INS> implicitly-declared
special member function <TT>f</TT> of some class <TT>X</TT><DEL>,
the <I>set of potential exceptions of the
implicitly-declared special member function</I> <TT>f</TT></DEL>
<INS>is considered to have an implicit exception
specification that</INS> consists of all the members from
the following sets:...

</BLOCKQUOTE>

<LI><P>Delete the normative text of 14.5 [<A href="https://wg21.link/except.spec#17">except.spec</A>] paragraph 17
and merge the example with the preceding paragraph:</P></LI>

<BLOCKQUOTE>

<P><DEL>An implicitly-declared special member function (
11.4.4 [<A href="https://wg21.link/special">special</A>]) is considered to have an implicit
exception specification, as follows, where <I>S</I> is the set of
potential exceptions of the implicitly-declared special
member function:</DEL></P>

<UL>
<LI><P><DEL>if <I>S</I> contains the pseudo-type &#8220;any&#8221;, the
implicit exception specification is the set of all types;</DEL></P></LI>

<LI><P><DEL>otherwise, the implicit exception specification contains all
the types in <I>S</I>.</DEL></P></LI>

</UL>

<P>[<I>Example:</I>...</P>

</BLOCKQUOTE>

</OL>

<BR><BR>
</BODY>
</HTML>
