<HTML>
<HEAD>
<meta http-equiv="Content-Type" content="text/html; charset=us-ascii">
<TITLE>
    CWG Issue 47</TITLE>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<STYLE TYPE="text/css">
  INS { text-decoration:none; font-weight:bold; background-color:#A0FFA0 }
  .INS { text-decoration:none; background-color:#D0FFD0 }
  DEL { text-decoration:line-through; background-color:#FFA0A0 }
  .DEL { text-decoration:line-through; background-color: #FFD0D0 }
  @media (prefers-color-scheme: dark) {
    HTML { background-color:#202020; color:#f0f0f0; }
    A { color:#5bc0ff; }
    A:visited { color:#c6a8ff; }
    A:hover, a:focus { color:#afd7ff; }
    INS { background-color:#033a16; color:#aff5b4; }
    .INS { background-color: #033a16; }
    DEL { background-color:#67060c; color:#ffdcd7; }
    .DEL { background-color:#67060c; }
  }
  SPAN.cmnt { font-family:Times; font-style:italic }
</STYLE>
</HEAD>
<BODY>
<P><EM>This is an unofficial snapshot of the ISO/IEC JTC1 SC22 WG21
  Core Issues List revision 116c.
  See http://www.open-std.org/jtc1/sc22/wg21/ for the official
  list.</EM></P>
<P>2025-03-08</P>
<HR>
<A NAME="47"></A><H4>47.
  
Template friend issues
</H4>
<B>Section: </B>13.7.5&#160; [<A href="https://wg21.link/temp.friend">temp.friend</A>]
 &#160;&#160;&#160;

 <B>Status: </B>NAD
 &#160;&#160;&#160;

 <B>Submitter: </B>John H. Spicer
 &#160;&#160;&#160;

 <B>Date: </B>7 Nov 1997<BR>




<P><U>Issue 1</U></P>

<P>Paragraph 1 says that a friend of a class template can be a template.
Paragraph 2 says: A friend template may be declared within a non-template
class. A friend function template may be defined within a non-template
class.</P>

<P>I'm not sure what this wording implies about friend template definitions
within template classes. The rules for class templates and normal classes
should be the same: a function template can be declared or defined, but
a class template can only be declared in a friend declaration.</P>

<P><U>Issue 2</U></P>

<P>Paragraph 4 says: When a function is defined in a friend function declaration
in a class template, the function is defined when the class template is
first instantiated. I take it that this was intended to mean that a function
that is defined in a class template is not defined until the first instantiation.
I think this should say that a function that is defined in a class template
is defined each time the class is instantiated. This means that a function
that is defined in a class template must depend on all of the template
parameters of the class template, otherwise multiple definition errors
could occur during instantiations. If we don't have a rule like this, compilers
would have to compare the definitions of functions to see whether they
are the same or not. For example:</P>
<PRE>
    template &lt;class T&gt; struct A {
            friend int f() { return sizeof(T); }
    };

    A&lt;int&gt; ai;
    A&lt;long&gt; ac;
</PRE>
I hope we would all agree that this program is ill-formed, even if long
and int have the same size.

<P><U>From Bill Gibbons:</U></P>

<P>[1] That sounds right.</P>

<P>[2] Whenever possible, I try to treat instantiated class templates as
if they were ordinary classes with funny names. If you write:</P>
<PRE>
    struct A_int {
        friend int f() { return sizeof(int); }
    };
    struct A_long {
        friend int f() { return sizeof(long); }
    };
</PRE>
it is a redefinition (which is not allowed) and an ODR violation. And if
you write:
<PRE>
    template &lt;class T, class U&gt; struct A {
                friend int f() { return sizeof(U); }
    };

    A&lt;int,float&gt; ai;
    A&lt;long,float&gt; ac;
</PRE>
the corresponding non-template code would be:
<PRE>
    struct A_int_float {
        friend int f() { return sizeof(float); }
    };
    struct A_long_float {
        friend int f() { return sizeof(float); }
    };
</PRE>
then the two definitions of "<TT>f</TT>" are identical so there is no ODR
violation, but it is still a redefinition. I think this is just an editorial
clarification.

<P>
<B>Rationale (04/99):</B> The first sub-issue reflects wording that was
changed to address the concern before the IS was issued.  A close and
careful reading of the Standard already leads to the conclusion that the
example in the second sub-issue is ill-formed, so no change is needed.</P>
<BR><BR>
</BODY>
</HTML>
