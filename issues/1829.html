<HTML>
<HEAD>
<meta http-equiv="Content-Type" content="text/html; charset=us-ascii">
<TITLE>
    CWG Issue 1829</TITLE>
<STYLE TYPE="text/css">
  INS { text-decoration:none; font-weight:bold; background-color:#A0FFA0 }
  .INS { text-decoration:none; background-color:#D0FFD0 }
  DEL { text-decoration:line-through; background-color:#FFA0A0 }
  .DEL { text-decoration:line-through; background-color: #FFD0D0 }
  SPAN.cmnt { font-family:Times; font-style:italic }
</STYLE>
</HEAD>
<BODY>
<P><EM>This is an unofficial snapshot of the ISO/IEC JTC1 SC22 WG21
  Core Issues List revision 116b.
  See http://www.open-std.org/jtc1/sc22/wg21/ for the official
  list.</EM></P>
<P>2025-03-05</P>
<HR>
<A NAME="1829"></A><H4>1829.
  
Dependent unnamed types
</H4>
<B>Section: </B>13.8.3.2&#160; [<A href="https://wg21.link/temp.dep.type">temp.dep.type</A>]
 &#160;&#160;&#160;

 <B>Status: </B>CD6
 &#160;&#160;&#160;

 <B>Submitter: </B>Hubert Tong
 &#160;&#160;&#160;

 <B>Date: </B>2014-01-08<BR>


<P>[Accepted at the November, 2020 meeting as part of paper P1787R6 and
moved to DR at the February, 2021 meeting.]</P>



<P>The specification of dependent types in 13.8.3.2 [<A href="https://wg21.link/temp.dep.type">temp.dep.type</A>]
is given in terms of names.  However, one might consider some unnamed
types as dependent.  Consider the following example:</P>

<PRE>
  template &lt;typename T&gt; struct A {
    struct { } obj;
    void foo() {
      bar(obj); //<SPAN CLASS="cmnt"> lookup for </SPAN>bar<SPAN CLASS="cmnt"> when/where?</SPAN>
    }
  };

  void bar(...);

  int main() {
    A&lt;int&gt; a;
    a.foo();    //<SPAN CLASS="cmnt"> calls </SPAN>bar(...)<SPAN CLASS="cmnt">?</SPAN>
  }
</PRE>

<P>If the type of <TT>A::obj</TT> had a name, it would be
dependent.  However, the rationale for making nested types
dependent is that they are subject to explicit
specialization and thus not knowable at the point of the
template definition.  An unnamed type, as in this example,
cannot be explicitly specialized and thus could be
considered as a member of the current instantiation.  Which
treatment is intended?</P>

<P><B>Notes from the February, 2014 meeting:</B></P>

<P>There are other cases in which a named entity is dependnet, even
though it cannot be explicitly specialized.  CWG felt that the most
consistent rule would be to make all nested classes dependent, whether
named or not.</P>

<BR><BR>
</BODY>
</HTML>
