<HTML>
<HEAD>
<meta http-equiv="Content-Type" content="text/html; charset=us-ascii">
<TITLE>
    CWG Issue 2803</TITLE>
<STYLE TYPE="text/css">
  INS { text-decoration:none; font-weight:bold; background-color:#A0FFA0 }
  .INS { text-decoration:none; background-color:#D0FFD0 }
  DEL { text-decoration:line-through; background-color:#FFA0A0 }
  .DEL { text-decoration:line-through; background-color: #FFD0D0 }
  SPAN.cmnt { font-family:Times; font-style:italic }
</STYLE>
</HEAD>
<BODY>
<P><EM>This is an unofficial snapshot of the ISO/IEC JTC1 SC22 WG21
  Core Issues List revision 116b.
  See http://www.open-std.org/jtc1/sc22/wg21/ for the official
  list.</EM></P>
<P>2025-03-05</P>
<HR>
<A NAME="2803"></A><H4>2803.
  
Overload resolution for reference binding of similar types
</H4>
<B>Section: </B>12.2.4.2.5&#160; [<A href="https://wg21.link/over.ics.ref">over.ics.ref</A>]
 &#160;&#160;&#160;

 <B>Status: </B>DRWP
 &#160;&#160;&#160;

 <B>Submitter: </B>Brian Bi
 &#160;&#160;&#160;

 <B>Date: </B>2023-06-14<BR>


<P>[Accepted as a DR at the March, 2024 meeting.]</P>



<P>Consider:</P>

<PRE>
  int foo(int*&amp; r);       //<SPAN CLASS="cmnt"> #1</SPAN>
  int foo(const int* const&amp; r); //<SPAN CLASS="cmnt"> #2</SPAN>

  int *p;
  int x = foo(p);
</PRE>

<P>Both #1 and #2 perform direct reference binding; no qualification
conversions are involved.  Despite the lack of a rule, implementations
prefer #1 over #2.</P>

<P><B>Proposed resolution (approved by CWG 2023-11-10):</B></P>

<OL>
<LI>
<P>Change in 12.2.4.2.5 [<A href="https://wg21.link/over.ics.ref#1">over.ics.ref</A>] paragraph 1 as follows:</P>

<BLOCKQUOTE>

When a parameter of <DEL>reference</DEL> type <INS>"reference
to <I>cv</I> <TT>T</TT>"</INS> binds directly
(9.4.4 [<A href="https://wg21.link/dcl.init.ref">dcl.init.ref</A>]) to an argument expression<DEL>, the
implicit conversion sequence is the identity conversion,
unless</DEL><INS>:</INS>

<UL>
<LI>
<INS>If</INS> the argument
expression has a type that is a derived class of the parameter type,
<DEL>in which case</DEL> the implicit conversion sequence is a derived-to-base
conversion (12.2.4.2 [<A href="https://wg21.link/over.best.ics">over.best.ics</A>]).</LI>
<LI class="ins">
Otherwise, if <TT>T</TT> is a function type, or if the type of the
argument is possibly cv-qualified <TT>T</TT>, or if <TT>T</TT> is an
array type of unknown bound with element type <TT>U</TT> and the
argument has an array type of known bound whose element type is
possibly cv-qualified <TT>U</TT>, the implicit conversion sequence is
the identity conversion.  [ <I>Note</I>: When T is a function type,
the type of the argument may differ only by the presence
of <TT>noexcept</TT>. -- end note]
</LI>
<LI class="ins">
Otherwise, the implicit conversion sequence is a qualification
conversion.
</LI>
</UL>

<P> [<I>Example 1:</I> ... &#8212;<I>end example</I>]</P>

If the parameter binds directly to the result of applying a conversion
function to the argument expression, the implicit conversion sequence
is a user-defined conversion sequence
(12.2.4.2.3 [<A href="https://wg21.link/over.ics.user">over.ics.user</A>]) whose second standard conversion
sequence is <DEL>either an identity conversion or, if the conversion
function returns an entity of a type that is a derived class of the
parameter type, a derived-to-base conversion</DEL> <INS>determined by
the above rules</INS>.

</BLOCKQUOTE>

</LI>

<LI>
<P>Change in 12.2.4.3 [<A href="https://wg21.link/over.ics.rank#3.2.5">over.ics.rank</A>] bullet 3.2.5 as follows:</P>

<BLOCKQUOTE>

<UL>
<LI>
S1 and S2 differ only in their qualification conversion
(7.3.6 [<A href="https://wg21.link/conv.qual">conv.qual</A>]) and yield similar types T1 and T2,
respectively <INS>(where a standard conversion sequence that is a
reference binding is considered to yield the cv-unqualified referenced
type)</INS>, where T1 <DEL>can be converted to T2 by a qualification
conversion</DEL> <INS>and T2 are not the same type, and <TT>const
T2</TT> is reference-compatible with <TT>T1</TT>
(9.4.4 [<A href="https://wg21.link/dcl.init.ref">dcl.init.ref</A>])</INS>.  [<I>Example 5:</I>
<PRE>
  int f(const volatile int *);
  int f(const int *);
  int i;
  int j = f(&amp;i);  //<SPAN CLASS="cmnt"> calls </SPAN>f(const int*)
<INS>  int g(const int*);
  int g(const volatile int* const&amp;);
  int* p;
  int k = g(p);          //<SPAN CLASS="cmnt"> calls </SPAN>g(const int*)</INS>
</PRE>
  -- end example]
  or, if not that,
</LI>
</UL>
</BLOCKQUOTE>
</LI>

<LI>
<P>Change in 12.2.4.3 [<A href="https://wg21.link/over.ics.rank#3.2.6">over.ics.rank</A>] bullet 3.2.6 as follows:</P>

<BLOCKQUOTE>

<UL>
<LI>
S1 and S2 <DEL>include reference bindings</DEL> <INS>bind "reference
to <TT>T1</TT>" and "reference to <TT>T2</TT>", respectively</INS>
(9.4.4 [<A href="https://wg21.link/dcl.init.ref">dcl.init.ref</A>]), <DEL>and the types to which the
references refer are the same type except for top-level cv-qualifiers,
and the type to which the reference initialized by S2 refers is more
cv-qualified than the type to which the reference initialized by S1
refers</DEL> <INS>where <TT>T1</TT> and <TT>T2</TT> are not the same
type, and <TT>T2</TT> is reference-compatible with <TT>T1</TT></INS>.
[<I>Example 6:</I> ...

<PRE class="ins">
   int h1(int (&amp;)[]);
   int h1(int (&amp;)[1]);
   int h2(void (&amp;)());
   int h2(void (&amp;)() noexcept);
   void g2() {
     int a[1];
     h1(a);            //<SPAN CLASS="cmnt"> calls </SPAN>h1(int (&amp;)[1])
     extern void f2() noexcept;
     h2(f2);            //<SPAN CLASS="cmnt"> calls </SPAN>h2(void (&amp;)() noexcept)
   }
</PRE>
-- end example ]
</LI>
</UL>

</BLOCKQUOTE>

</LI>
</OL>

<BR><BR>
</BODY>
</HTML>
