<HTML>
<HEAD>
<meta http-equiv="Content-Type" content="text/html; charset=us-ascii">
<TITLE>
    CWG Issue 1935</TITLE>
<STYLE TYPE="text/css">
  INS { text-decoration:none; font-weight:bold; background-color:#A0FFA0 }
  .INS { text-decoration:none; background-color:#D0FFD0 }
  DEL { text-decoration:line-through; background-color:#FFA0A0 }
  .DEL { text-decoration:line-through; background-color: #FFD0D0 }
  SPAN.cmnt { font-family:Times; font-style:italic }
</STYLE>
</HEAD>
<BODY>
<P><EM>This is an unofficial snapshot of the ISO/IEC JTC1 SC22 WG21
  Core Issues List revision 116.
  See http://www.open-std.org/jtc1/sc22/wg21/ for the official
  list.</EM></P>
<P>2024-12-19</P>
<HR>
<A NAME="1935"></A><H4>1935.
  
Reuse of placement arguments in deallocation
</H4>
<B>Section: </B>7.6.2.8&#160; [<A href="https://wg21.link/expr.new">expr.new</A>]
 &#160;&#160;&#160;

 <B>Status: </B>CD5
 &#160;&#160;&#160;

 <B>Submitter: </B>Hubert Tong
 &#160;&#160;&#160;

 <B>Date: </B>2014-06-04<BR>


<P>[Resolved by CWG1880 (November, 2014) and CWG2177 (November, 2017).]</P>



<P>The description in 7.6.2.8 [<A href="https://wg21.link/expr.new">expr.new</A>] paragraph
23 regarding calling a deallocation function following an
exception during the initialization of an object resulting
from a placement <I>new-expression</I> says,</P>

<BLOCKQUOTE>

If a placement deallocation function is called, it is passed
the same additional arguments as were passed to the
placement allocation function, that is, the same arguments
as those specified with the <I>new-placement</I> syntax. If
the implementation is allowed to make a copy of any argument
as part of the call to the allocation function, it is
allowed to make a copy (of the same original value) as part
of the call to the deallocation function or to reuse the
copy made as part of the call to the allocation function. If
the copy is elided in one place, it need not be elided in
the other.

</BLOCKQUOTE>

<P>This seems curious, as it allows reuse of a parameter object
that presumably is destroyed immediately upon the return of the
allocation function (but see <A HREF="1880.html">issue 1880</A>
for a question about the timing of such destructions).</P>

<P><B>Notes from the November, 2014 meeting:</B></P>

<P>The resolution for <A HREF="1880.html">issue 1880</A> should
mostly resolve this issue.  The resolution should handle the case in
which an object can only be constructed into the parameter object
and neither copied nor moved.</P>

<P><B>Additional notes (July, 2022):</B></P>

<P>
<A HREF="1880.html">Issue 1880</A> permitted the destruction of
parameter objects at the end of the full-expression enclosing the
function call.  <A HREF="2177.html">Issue 2177</A> clarified the
exceptions to the parameter object reuse.</P>

<P><B>Additional notes (CWG teleconference 2022-08-12):</B></P>

<P>This issue is resolved by issues <A HREF="1880.html">1880</A>
and <A HREF="2177.html">2177</A>.  Reusing the parameter objects of
the placement-new call for the placement-delete invocation is
intentional.</P>

<BR><BR>
</BODY>
</HTML>
