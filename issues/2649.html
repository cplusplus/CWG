<HTML>
<HEAD>
<meta http-equiv="Content-Type" content="text/html; charset=us-ascii">
<TITLE>
    CWG Issue 2649</TITLE>
<STYLE TYPE="text/css">
  INS { text-decoration:none; font-weight:bold; background-color:#A0FFA0 }
  .INS { text-decoration:none; background-color:#D0FFD0 }
  DEL { text-decoration:line-through; background-color:#FFA0A0 }
  .DEL { text-decoration:line-through; background-color: #FFD0D0 }
  SPAN.cmnt { font-family:Times; font-style:italic }
</STYLE>
</HEAD>
<BODY>
<P><EM>This is an unofficial snapshot of the ISO/IEC JTC1 SC22 WG21
  Core Issues List revision 116a.
  See http://www.open-std.org/jtc1/sc22/wg21/ for the official
  list.</EM></P>
<P>2024-12-19</P>
<HR>
<A NAME="2649"></A><H4>2649.
  
Incorrect note about implicit conversion sequence
</H4>
<B>Section: </B>12.2.2.2.3&#160; [<A href="https://wg21.link/over.call.object">over.call.object</A>]
 &#160;&#160;&#160;

 <B>Status: </B>C++23
 &#160;&#160;&#160;

 <B>Submitter: </B>CA
 &#160;&#160;&#160;

 <B>Date: </B>2022-11-03<BR><BR>


<A href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2720r0.pdf#CA064">P2720R0 comment
  CA&#160;064<BR></A>

<P>[Accepted as a DR at the November, 2022 meeting.]</P>

<P>
Contrary to the note in the subject paragraph, overload resolution in
selecting a surrogate call function can prefer a different conversion
operator for the implicit conversion sequence because the conversion
function from which the surrogate call function was derived is not the
best viable function.
</P>

<P>
For example, noting that surrogate call functions are not generated
from conversion function templates, the single surrogate call function
derived from the (non-template) conversion function below is the sole
candidate for the call; however, the specialization of the conversion
function template is a better candidate f or the implicit conversion
sequence during overload resolution:
</P>

<PRE>
  using ff = int (*)(int);
  constexpr int ffimpl0(int x) {
   return x;
  }
  constexpr int ffimpl1(int x) {
   return x + 1;
  }
  struct A {
   template &lt;typename T&gt; constexpr operator T() const { return ffimpl0; }
   constexpr operator ff() const volatile { return ffimpl1; }
  };
  char x[A()(42.f)];
  extern char x[43];
</PRE>

<P><B>Proposed resolution (approved CWG 2022-11-08):</B></P>

<P>Change in 12.2.2.2.3 [<A href="https://wg21.link/over.call.object#3">over.call.object</A>] paragraph 3 as follows:</P>

<BLOCKQUOTE>

[<I>Note 1:</I> When comparing the call against the function call
operators, the implied object argument is compared against the object
parameter of the function call operator. When comparing the call
against a surrogate call function, the implied object argument is
compared against the first parameter of the surrogate call
function. <DEL>The conversion function from which the surrogate call
function was derived will be used in the conversion sequence for that
parameter since it converts the implied object argument to the
appropriate function pointer or reference required by that first
parameter.</DEL> &#8212;<I>end note</I>]

</BLOCKQUOTE>

<BR><BR>
</BODY>
</HTML>
