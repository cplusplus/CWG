<HTML>
<HEAD>
<meta http-equiv="Content-Type" content="text/html; charset=us-ascii">
<TITLE>
    CWG Issue 2013</TITLE>
<STYLE TYPE="text/css">
  INS { text-decoration:none; font-weight:bold; background-color:#A0FFA0 }
  .INS { text-decoration:none; background-color:#D0FFD0 }
  DEL { text-decoration:line-through; background-color:#FFA0A0 }
  .DEL { text-decoration:line-through; background-color: #FFD0D0 }
  SPAN.cmnt { font-family:Times; font-style:italic }
</STYLE>
</HEAD>
<BODY>
<P><EM>This is an unofficial snapshot of the ISO/IEC JTC1 SC22 WG21
  Core Issues List revision 116b.
  See http://www.open-std.org/jtc1/sc22/wg21/ for the official
  list.</EM></P>
<P>2025-03-05</P>
<HR>
<A NAME="2013"></A><H4>2013.
  
Pointer subtraction in large array
</H4>
<B>Section: </B>7.6.6&#160; [<A href="https://wg21.link/expr.add">expr.add</A>]
 &#160;&#160;&#160;

 <B>Status: </B>drafting
 &#160;&#160;&#160;

 <B>Submitter: </B>Jason Merrill
 &#160;&#160;&#160;

 <B>Date: </B>2014-10-02<BR>




<P>The common code sequence used by most implementations for
pointer subtraction involves subtracting the pointer values
to determine the number of bytes and then shifting to scale
for the size of the array element.  This produces incorrect
results when the difference in bytes is larger than can be
represented by a <TT>ptrdiff_t</TT>.  For example, assuming
a 32-bit <TT>ptrdiff_t</TT>:</P>

<PRE>
  int *a, *b;
  a = malloc(0x21000000 * sizeof(int));
  b = a + 0x21000000;
  printf("%lx\n", (long)(b - a));
</PRE>

<P>This will typically print e1000000 instead of 21000000.</P>

<P>Getting the right answer would require using a more expensive
code sequence.  It would be better to make this undefined
behavior.</P>

<BR><BR>
</BODY>
</HTML>
